// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cloudlet.proto

package ormctl

import (
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/mobiledgex/edge-cloud-infra/mc/ormapi"
	_ "github.com/mobiledgex/edge-cloud/d-match-engine/dme-proto"
	edgeproto "github.com/mobiledgex/edge-cloud/edgeproto"
	_ "github.com/mobiledgex/edge-cloud/protogen"
	math "math"
	"strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT

var CreateGPUDriverCmd = &ApiCommand{
	Name:                 "CreateGPUDriver",
	Use:                  "create",
	Short:                "Create GPU Driver. Creates GPU driver with all the config required to install it.",
	RequiredArgs:         "region " + strings.Join(GPUDriverRequiredArgs, " "),
	OptionalArgs:         strings.Join(GPUDriverOptionalArgs, " "),
	AliasArgs:            strings.Join(GPUDriverAliasArgs, " "),
	SpecialArgs:          &GPUDriverSpecialArgs,
	Comments:             addRegionComment(GPUDriverComments),
	NoConfig:             "State,LicenseConfigMd5Sum,DeletePrepare",
	ReqData:              &ormapi.RegionGPUDriver{},
	ReplyData:            &edgeproto.Result{},
	Path:                 "/auth/ctrl/CreateGPUDriver",
	StreamOut:            true,
	StreamOutIncremental: true,
	ProtobufApi:          true,
}

var DeleteGPUDriverCmd = &ApiCommand{
	Name:                 "DeleteGPUDriver",
	Use:                  "delete",
	Short:                "Delete GPU Driver. Deletes GPU driver given that it is not used by any cloudlet.",
	RequiredArgs:         "region " + strings.Join(GPUDriverRequiredArgs, " "),
	OptionalArgs:         strings.Join(GPUDriverOptionalArgs, " "),
	AliasArgs:            strings.Join(GPUDriverAliasArgs, " "),
	SpecialArgs:          &GPUDriverSpecialArgs,
	Comments:             addRegionComment(GPUDriverComments),
	NoConfig:             "State,LicenseConfigMd5Sum,DeletePrepare",
	ReqData:              &ormapi.RegionGPUDriver{},
	ReplyData:            &edgeproto.Result{},
	Path:                 "/auth/ctrl/DeleteGPUDriver",
	StreamOut:            true,
	StreamOutIncremental: true,
	ProtobufApi:          true,
}

var UpdateGPUDriverCmd = &ApiCommand{
	Name:                 "UpdateGPUDriver",
	Use:                  "update",
	Short:                "Update GPU Driver. Updates GPU driver config.",
	RequiredArgs:         "region " + strings.Join(UpdateGPUDriverRequiredArgs, " "),
	OptionalArgs:         strings.Join(UpdateGPUDriverOptionalArgs, " "),
	AliasArgs:            strings.Join(GPUDriverAliasArgs, " "),
	SpecialArgs:          &GPUDriverSpecialArgs,
	Comments:             addRegionComment(GPUDriverComments),
	NoConfig:             "State,LicenseConfigMd5Sum,DeletePrepare,Builds,Type,IgnoreState",
	ReqData:              &ormapi.RegionGPUDriver{},
	ReplyData:            &edgeproto.Result{},
	Path:                 "/auth/ctrl/UpdateGPUDriver",
	StreamOut:            true,
	StreamOutIncremental: true,
	ProtobufApi:          true,
}

var ShowGPUDriverCmd = &ApiCommand{
	Name:                 "ShowGPUDriver",
	Use:                  "show",
	Short:                "Show GPU Drivers. Lists all the MobiledgeX created GPU drivers and operator created GPU drivers.",
	RequiredArgs:         "region",
	OptionalArgs:         strings.Join(append(GPUDriverRequiredArgs, GPUDriverOptionalArgs...), " "),
	AliasArgs:            strings.Join(GPUDriverAliasArgs, " "),
	SpecialArgs:          &GPUDriverSpecialArgs,
	Comments:             addRegionComment(GPUDriverComments),
	NoConfig:             "State,LicenseConfigMd5Sum,DeletePrepare",
	ReqData:              &ormapi.RegionGPUDriver{},
	ReplyData:            &edgeproto.GPUDriver{},
	Path:                 "/auth/ctrl/ShowGPUDriver",
	StreamOut:            true,
	StreamOutIncremental: true,
	ProtobufApi:          true,
}

var AddGPUDriverBuildCmd = &ApiCommand{
	Name:                 "AddGPUDriverBuild",
	Use:                  "addbuild",
	Short:                "Add GPU Driver Build. Adds new build to GPU driver.",
	RequiredArgs:         "region " + strings.Join(AddGPUDriverBuildRequiredArgs, " "),
	OptionalArgs:         strings.Join(AddGPUDriverBuildOptionalArgs, " "),
	AliasArgs:            strings.Join(GPUDriverBuildMemberAliasArgs, " "),
	SpecialArgs:          &GPUDriverBuildMemberSpecialArgs,
	Comments:             addRegionComment(GPUDriverBuildMemberComments),
	ReqData:              &ormapi.RegionGPUDriverBuildMember{},
	ReplyData:            &edgeproto.Result{},
	Path:                 "/auth/ctrl/AddGPUDriverBuild",
	StreamOut:            true,
	StreamOutIncremental: true,
	ProtobufApi:          true,
}

var RemoveGPUDriverBuildCmd = &ApiCommand{
	Name:                 "RemoveGPUDriverBuild",
	Use:                  "removebuild",
	Short:                "Remove GPU Driver Build. Removes build from GPU driver.",
	RequiredArgs:         "region " + strings.Join(RemoveGPUDriverBuildRequiredArgs, " "),
	OptionalArgs:         strings.Join(RemoveGPUDriverBuildOptionalArgs, " "),
	AliasArgs:            strings.Join(GPUDriverBuildMemberAliasArgs, " "),
	SpecialArgs:          &GPUDriverBuildMemberSpecialArgs,
	Comments:             addRegionComment(GPUDriverBuildMemberComments),
	NoConfig:             "Build.DriverPath,Build.OperatingSystem,Build.KernelVersion,Build.HypervisorInfo",
	ReqData:              &ormapi.RegionGPUDriverBuildMember{},
	ReplyData:            &edgeproto.Result{},
	Path:                 "/auth/ctrl/RemoveGPUDriverBuild",
	StreamOut:            true,
	StreamOutIncremental: true,
	ProtobufApi:          true,
}

var GetGPUDriverBuildURLCmd = &ApiCommand{
	Name:         "GetGPUDriverBuildURL",
	Use:          "getbuildurl",
	Short:        "Get GPU Driver Build URL. Returns a time-limited signed URL to download GPU driver.",
	RequiredArgs: "region " + strings.Join(GetGPUDriverBuildURLRequiredArgs, " "),
	OptionalArgs: strings.Join(GetGPUDriverBuildURLOptionalArgs, " "),
	AliasArgs:    strings.Join(GPUDriverBuildMemberAliasArgs, " "),
	SpecialArgs:  &GPUDriverBuildMemberSpecialArgs,
	Comments:     addRegionComment(GPUDriverBuildMemberComments),
	NoConfig:     "Build.DriverPath,Build.OperatingSystem,Build.KernelVersion,Build.HypervisorInfo,Build.DriverPathCreds,Build.Md5Sum",
	ReqData:      &ormapi.RegionGPUDriverBuildMember{},
	ReplyData:    &edgeproto.GPUDriverBuildURL{},
	Path:         "/auth/ctrl/GetGPUDriverBuildURL",
	ProtobufApi:  true,
}
var GPUDriverApiCmds = []*ApiCommand{
	CreateGPUDriverCmd,
	DeleteGPUDriverCmd,
	UpdateGPUDriverCmd,
	ShowGPUDriverCmd,
	AddGPUDriverBuildCmd,
	RemoveGPUDriverBuildCmd,
	GetGPUDriverBuildURLCmd,
}

const GPUDriverGroup = "GPUDriver"

func init() {
	AllApis.AddGroup(GPUDriverGroup, "Manage GPUDrivers", GPUDriverApiCmds)
}

var UpdateGPUDriverRequiredArgs = []string{
	"gpudrivername",
}
var UpdateGPUDriverOptionalArgs = []string{
	"gpudriverorg",
	"licenseconfig",
	"properties",
}
var AddGPUDriverBuildRequiredArgs = []string{
	"gpudrivername",
	"gpudriverorg",
	"build.name",
	"build.driverpath",
	"build.operatingsystem",
	"build.md5sum",
}
var AddGPUDriverBuildOptionalArgs = []string{
	"build.driverpathcreds",
	"build.kernelversion",
	"build.hypervisorinfo",
	"ignorestate",
}
var RemoveGPUDriverBuildRequiredArgs = []string{
	"gpudrivername",
	"gpudriverorg",
	"build.name",
}
var RemoveGPUDriverBuildOptionalArgs = []string{
	"build.driverpathcreds",
	"build.md5sum",
	"ignorestate",
}
var GetGPUDriverBuildURLRequiredArgs = []string{
	"gpudrivername",
	"gpudriverorg",
	"build.name",
}
var GetGPUDriverBuildURLOptionalArgs = []string{
	"ignorestate",
}

var CreateCloudletCmd = &ApiCommand{
	Name:                 "CreateCloudlet",
	Use:                  "create",
	Short:                "Create Cloudlet. Sets up Cloudlet services on the Operators compute resources, and integrated as part of MobiledgeX edge resource portfolio. These resources are managed from the Edge Controller.",
	RequiredArgs:         "region " + strings.Join(CreateCloudletRequiredArgs, " "),
	OptionalArgs:         strings.Join(CreateCloudletOptionalArgs, " "),
	AliasArgs:            strings.Join(CloudletAliasArgs, " "),
	SpecialArgs:          &CloudletSpecialArgs,
	Comments:             addRegionComment(CloudletComments),
	NoConfig:             "Location.HorizontalAccuracy,Location.VerticalAccuracy,Location.Course,Location.Speed,Location.Timestamp,Config,ChefClientKey,State,Errors,CrmAccessPublicKey,CrmAccessKeyUpgradeRequired,SecondaryCrmAccessPublicKey,SecondaryCrmAccessKeyUpgradeRequired,CreatedAt,UpdatedAt,TrustPolicyState,HostController,DeletePrepare,GpuConfig.LicenseConfigMd5Sum,DnsLabel,RootLbFqdn,FederationConfig,ResTagMap",
	ReqData:              &ormapi.RegionCloudlet{},
	ReplyData:            &edgeproto.Result{},
	Path:                 "/auth/ctrl/CreateCloudlet",
	StreamOut:            true,
	StreamOutIncremental: true,
	ProtobufApi:          true,
}

var DeleteCloudletCmd = &ApiCommand{
	Name:                 "DeleteCloudlet",
	Use:                  "delete",
	Short:                "Delete Cloudlet. Removes the Cloudlet services where they are no longer managed from the Edge Controller.",
	RequiredArgs:         "region " + strings.Join(DeleteCloudletRequiredArgs, " "),
	OptionalArgs:         strings.Join(DeleteCloudletOptionalArgs, " "),
	AliasArgs:            strings.Join(CloudletAliasArgs, " "),
	SpecialArgs:          &CloudletSpecialArgs,
	Comments:             addRegionComment(CloudletComments),
	NoConfig:             "Location.HorizontalAccuracy,Location.VerticalAccuracy,Location.Course,Location.Speed,Location.Timestamp,Config,ChefClientKey,State,Errors,CrmAccessPublicKey,CrmAccessKeyUpgradeRequired,SecondaryCrmAccessPublicKey,SecondaryCrmAccessKeyUpgradeRequired,CreatedAt,UpdatedAt,TrustPolicyState,HostController,DeletePrepare,GpuConfig.LicenseConfigMd5Sum,DnsLabel,RootLbFqdn,FederationConfig,ResTagMap",
	ReqData:              &ormapi.RegionCloudlet{},
	ReplyData:            &edgeproto.Result{},
	Path:                 "/auth/ctrl/DeleteCloudlet",
	StreamOut:            true,
	StreamOutIncremental: true,
	ProtobufApi:          true,
}

var UpdateCloudletCmd = &ApiCommand{
	Name:                 "UpdateCloudlet",
	Use:                  "update",
	Short:                "Update Cloudlet. Updates the Cloudlet configuration and manages the upgrade of Cloudlet services.",
	RequiredArgs:         "region " + strings.Join(UpdateCloudletRequiredArgs, " "),
	OptionalArgs:         strings.Join(UpdateCloudletOptionalArgs, " "),
	AliasArgs:            strings.Join(CloudletAliasArgs, " "),
	SpecialArgs:          &CloudletSpecialArgs,
	Comments:             addRegionComment(CloudletComments),
	NoConfig:             "Location.HorizontalAccuracy,Location.VerticalAccuracy,Location.Course,Location.Speed,Location.Timestamp,Config,ChefClientKey,State,Errors,CrmAccessPublicKey,CrmAccessKeyUpgradeRequired,SecondaryCrmAccessPublicKey,SecondaryCrmAccessKeyUpgradeRequired,CreatedAt,UpdatedAt,TrustPolicyState,HostController,DeletePrepare,GpuConfig.LicenseConfigMd5Sum,DnsLabel,RootLbFqdn,FederationConfig,PlatformType,DeploymentLocal,Flavor,PhysicalName,ContainerVersion,ResTagMap,VmImageVersion,Deployment,InfraApiAccess,InfraConfig,OverridePolicyContainerVersion,VmPool,ResTagMap",
	ReqData:              &ormapi.RegionCloudlet{},
	ReplyData:            &edgeproto.Result{},
	Path:                 "/auth/ctrl/UpdateCloudlet",
	StreamOut:            true,
	StreamOutIncremental: true,
	ProtobufApi:          true,
}

var ShowCloudletCmd = &ApiCommand{
	Name:         "ShowCloudlet",
	Use:          "show",
	Short:        "Show Cloudlets. Lists all the cloudlets managed from Edge Controller.",
	RequiredArgs: "region",
	OptionalArgs: strings.Join(append(CloudletRequiredArgs, CloudletOptionalArgs...), " "),
	AliasArgs:    strings.Join(CloudletAliasArgs, " "),
	SpecialArgs:  &CloudletSpecialArgs,
	Comments:     addRegionComment(CloudletComments),
	NoConfig:     "Location.HorizontalAccuracy,Location.VerticalAccuracy,Location.Course,Location.Speed,Location.Timestamp,Config,ChefClientKey,State,Errors,CrmAccessPublicKey,CrmAccessKeyUpgradeRequired,SecondaryCrmAccessPublicKey,SecondaryCrmAccessKeyUpgradeRequired,CreatedAt,UpdatedAt,TrustPolicyState,HostController,DeletePrepare,GpuConfig.LicenseConfigMd5Sum,DnsLabel,RootLbFqdn,FederationConfig,ResTagMap",
	ReqData:      &ormapi.RegionCloudlet{},
	ReplyData:    &edgeproto.Cloudlet{},
	Path:         "/auth/ctrl/ShowCloudlet",
	StreamOut:    true,
	ProtobufApi:  true,
}

var GetCloudletManifestCmd = &ApiCommand{
	Name:         "GetCloudletManifest",
	Use:          "getmanifest",
	Short:        "Get Cloudlet Manifest. Shows deployment manifest required to setup cloudlet",
	RequiredArgs: "region " + strings.Join(CloudletKeyRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletKeyOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletKeyAliasArgs, " "),
	SpecialArgs:  &CloudletKeySpecialArgs,
	Comments:     addRegionComment(CloudletKeyComments),
	ReqData:      &ormapi.RegionCloudletKey{},
	ReplyData:    &edgeproto.CloudletManifest{},
	Path:         "/auth/ctrl/GetCloudletManifest",
	ProtobufApi:  true,
}

var GetCloudletPropsCmd = &ApiCommand{
	Name:         "GetCloudletProps",
	Use:          "getprops",
	Short:        "Get Cloudlet Properties. Shows all the infra properties used to setup cloudlet",
	RequiredArgs: "region " + strings.Join(GetCloudletPropsRequiredArgs, " "),
	OptionalArgs: strings.Join(GetCloudletPropsOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletPropsAliasArgs, " "),
	SpecialArgs:  &CloudletPropsSpecialArgs,
	Comments:     addRegionComment(CloudletPropsComments),
	NoConfig:     "Properties",
	ReqData:      &ormapi.RegionCloudletProps{},
	ReplyData:    &edgeproto.CloudletProps{},
	Path:         "/auth/ctrl/GetCloudletProps",
	ProtobufApi:  true,
}

var GetCloudletResourceQuotaPropsCmd = &ApiCommand{
	Name:         "GetCloudletResourceQuotaProps",
	Use:          "getresourcequotaprops",
	Short:        "Get Cloudlet Resource Quota Properties. Shows all the resource quota properties of the cloudlet",
	RequiredArgs: "region " + strings.Join(GetCloudletResourceQuotaPropsRequiredArgs, " "),
	OptionalArgs: strings.Join(GetCloudletResourceQuotaPropsOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletResourceQuotaPropsAliasArgs, " "),
	SpecialArgs:  &CloudletResourceQuotaPropsSpecialArgs,
	Comments:     addRegionComment(CloudletResourceQuotaPropsComments),
	NoConfig:     "Properties",
	ReqData:      &ormapi.RegionCloudletResourceQuotaProps{},
	ReplyData:    &edgeproto.CloudletResourceQuotaProps{},
	Path:         "/auth/ctrl/GetCloudletResourceQuotaProps",
	ProtobufApi:  true,
}

var GetCloudletResourceUsageCmd = &ApiCommand{
	Name:         "GetCloudletResourceUsage",
	Use:          "getresourceusage",
	Short:        "Get Cloudlet resource information. Shows cloudlet resources used and their limits",
	RequiredArgs: "region " + strings.Join(GetCloudletResourceUsageRequiredArgs, " "),
	OptionalArgs: strings.Join(GetCloudletResourceUsageOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletResourceUsageAliasArgs, " "),
	SpecialArgs:  &CloudletResourceUsageSpecialArgs,
	Comments:     addRegionComment(CloudletResourceUsageComments),
	NoConfig:     "Info",
	ReqData:      &ormapi.RegionCloudletResourceUsage{},
	ReplyData:    &edgeproto.CloudletResourceUsage{},
	Path:         "/auth/ctrl/GetCloudletResourceUsage",
	ProtobufApi:  true,
}

var AddCloudletResMappingCmd = &ApiCommand{
	Name:         "AddCloudletResMapping",
	Use:          "addresmapping",
	Short:        "Add Optional Resource tag table",
	RequiredArgs: "region " + strings.Join(CloudletResMapRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletResMapOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletResMapAliasArgs, " "),
	SpecialArgs:  &CloudletResMapSpecialArgs,
	Comments:     addRegionComment(CloudletResMapComments),
	ReqData:      &ormapi.RegionCloudletResMap{},
	ReplyData:    &edgeproto.Result{},
	Path:         "/auth/ctrl/AddCloudletResMapping",
	ProtobufApi:  true,
}

var RemoveCloudletResMappingCmd = &ApiCommand{
	Name:         "RemoveCloudletResMapping",
	Use:          "removeresmapping",
	Short:        "Remove Optional Resource tag table",
	RequiredArgs: "region " + strings.Join(CloudletResMapRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletResMapOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletResMapAliasArgs, " "),
	SpecialArgs:  &CloudletResMapSpecialArgs,
	Comments:     addRegionComment(CloudletResMapComments),
	ReqData:      &ormapi.RegionCloudletResMap{},
	ReplyData:    &edgeproto.Result{},
	Path:         "/auth/ctrl/RemoveCloudletResMapping",
	ProtobufApi:  true,
}

var AddCloudletAllianceOrgCmd = &ApiCommand{
	Name:         "AddCloudletAllianceOrg",
	Use:          "addallianceorg",
	Short:        "Add alliance organization to the cloudlet",
	RequiredArgs: "region " + strings.Join(CloudletAllianceOrgRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletAllianceOrgOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletAllianceOrgAliasArgs, " "),
	SpecialArgs:  &CloudletAllianceOrgSpecialArgs,
	Comments:     addRegionComment(CloudletAllianceOrgComments),
	ReqData:      &ormapi.RegionCloudletAllianceOrg{},
	ReplyData:    &edgeproto.Result{},
	Path:         "/auth/ctrl/AddCloudletAllianceOrg",
	ProtobufApi:  true,
}

var RemoveCloudletAllianceOrgCmd = &ApiCommand{
	Name:         "RemoveCloudletAllianceOrg",
	Use:          "removeallianceorg",
	Short:        "Remove alliance organization from the cloudlet",
	RequiredArgs: "region " + strings.Join(CloudletAllianceOrgRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletAllianceOrgOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletAllianceOrgAliasArgs, " "),
	SpecialArgs:  &CloudletAllianceOrgSpecialArgs,
	Comments:     addRegionComment(CloudletAllianceOrgComments),
	ReqData:      &ormapi.RegionCloudletAllianceOrg{},
	ReplyData:    &edgeproto.Result{},
	Path:         "/auth/ctrl/RemoveCloudletAllianceOrg",
	ProtobufApi:  true,
}

var FindFlavorMatchCmd = &ApiCommand{
	Name:         "FindFlavorMatch",
	Use:          "findflavormatch",
	Short:        "Discover if flavor produces a matching platform flavor",
	RequiredArgs: "region " + strings.Join(FlavorMatchRequiredArgs, " "),
	OptionalArgs: strings.Join(FlavorMatchOptionalArgs, " "),
	AliasArgs:    strings.Join(FlavorMatchAliasArgs, " "),
	SpecialArgs:  &FlavorMatchSpecialArgs,
	Comments:     addRegionComment(FlavorMatchComments),
	ReqData:      &ormapi.RegionFlavorMatch{},
	ReplyData:    &edgeproto.FlavorMatch{},
	Path:         "/auth/ctrl/FindFlavorMatch",
	ProtobufApi:  true,
}

var ShowFlavorsForCloudletCmd = &ApiCommand{
	Name:                 "ShowFlavorsForCloudlet",
	Use:                  "showflavorsfor",
	Short:                "Find all meta flavors viable on cloudlet",
	RequiredArgs:         "region " + strings.Join(ShowFlavorsForCloudletRequiredArgs, " "),
	OptionalArgs:         strings.Join(ShowFlavorsForCloudletOptionalArgs, " "),
	AliasArgs:            strings.Join(CloudletKeyAliasArgs, " "),
	SpecialArgs:          &CloudletKeySpecialArgs,
	Comments:             addRegionComment(CloudletKeyComments),
	ReqData:              &ormapi.RegionCloudletKey{},
	ReplyData:            &edgeproto.FlavorKey{},
	Path:                 "/auth/ctrl/ShowFlavorsForCloudlet",
	StreamOut:            true,
	StreamOutIncremental: true,
	ProtobufApi:          true,
}

var GetOrganizationsOnCloudletCmd = &ApiCommand{
	Name:                 "GetOrganizationsOnCloudlet",
	Use:                  "getorganizationson",
	Short:                "Get organizations of ClusterInsts and AppInsts on cloudlet",
	RequiredArgs:         "region " + strings.Join(CloudletKeyRequiredArgs, " "),
	OptionalArgs:         strings.Join(CloudletKeyOptionalArgs, " "),
	AliasArgs:            strings.Join(CloudletKeyAliasArgs, " "),
	SpecialArgs:          &CloudletKeySpecialArgs,
	Comments:             addRegionComment(CloudletKeyComments),
	ReqData:              &ormapi.RegionCloudletKey{},
	ReplyData:            &edgeproto.Organization{},
	Path:                 "/auth/ctrl/GetOrganizationsOnCloudlet",
	StreamOut:            true,
	StreamOutIncremental: true,
	ProtobufApi:          true,
}

var RevokeAccessKeyCmd = &ApiCommand{
	Name:         "RevokeAccessKey",
	Use:          "revokeaccesskey",
	Short:        "Revoke crm access key",
	RequiredArgs: "region " + strings.Join(CloudletKeyRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletKeyOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletKeyAliasArgs, " "),
	SpecialArgs:  &CloudletKeySpecialArgs,
	Comments:     addRegionComment(CloudletKeyComments),
	ReqData:      &ormapi.RegionCloudletKey{},
	ReplyData:    &edgeproto.Result{},
	Path:         "/auth/ctrl/RevokeAccessKey",
	ProtobufApi:  true,
}

var GenerateAccessKeyCmd = &ApiCommand{
	Name:         "GenerateAccessKey",
	Use:          "generateaccesskey",
	Short:        "Generate new crm access key",
	RequiredArgs: "region " + strings.Join(CloudletKeyRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletKeyOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletKeyAliasArgs, " "),
	SpecialArgs:  &CloudletKeySpecialArgs,
	Comments:     addRegionComment(CloudletKeyComments),
	ReqData:      &ormapi.RegionCloudletKey{},
	ReplyData:    &edgeproto.Result{},
	Path:         "/auth/ctrl/GenerateAccessKey",
	ProtobufApi:  true,
}
var CloudletApiCmds = []*ApiCommand{
	CreateCloudletCmd,
	DeleteCloudletCmd,
	UpdateCloudletCmd,
	ShowCloudletCmd,
	GetCloudletManifestCmd,
	GetCloudletPropsCmd,
	GetCloudletResourceQuotaPropsCmd,
	GetCloudletResourceUsageCmd,
	AddCloudletResMappingCmd,
	RemoveCloudletResMappingCmd,
	AddCloudletAllianceOrgCmd,
	RemoveCloudletAllianceOrgCmd,
	FindFlavorMatchCmd,
	ShowFlavorsForCloudletCmd,
	GetOrganizationsOnCloudletCmd,
	RevokeAccessKeyCmd,
	GenerateAccessKeyCmd,
}

const CloudletGroup = "Cloudlet"

func init() {
	AllApis.AddGroup(CloudletGroup, "Manage Cloudlets", CloudletApiCmds)
}

var CreateCloudletRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
	"location.latitude",
	"location.longitude",
	"numdynamicips",
}
var CreateCloudletOptionalArgs = []string{
	"federatedorg",
	"location.altitude",
	"ipsupport",
	"staticips",
	"timelimits.createclusterinsttimeout",
	"timelimits.updateclusterinsttimeout",
	"timelimits.deleteclusterinsttimeout",
	"timelimits.createappinsttimeout",
	"timelimits.updateappinsttimeout",
	"timelimits.deleteappinsttimeout",
	"crmoverride",
	"deploymentlocal",
	"platformtype",
	"notifysrvaddr",
	"flavor.name",
	"physicalname",
	"envvar",
	"containerversion",
	"accessvars",
	"vmimageversion",
	"deployment",
	"infraapiaccess",
	"infraconfig.externalnetworkname",
	"infraconfig.flavorname",
	"maintenancestate",
	"overridepolicycontainerversion",
	"vmpool",
	"trustpolicy",
	"resourcequotas:#.name",
	"resourcequotas:#.value",
	"resourcequotas:#.alertthreshold",
	"defaultresourcealertthreshold",
	"kafkacluster",
	"kafkauser",
	"kafkapassword",
	"gpuconfig.driver.name",
	"gpuconfig.driver.organization",
	"gpuconfig.properties",
	"gpuconfig.licenseconfig",
	"enabledefaultserverlesscluster",
	"allianceorgs",
	"singlekubernetesclusterowner",
	"platformhighavailability",
	"secondarynotifysrvaddr",
}
var DeleteCloudletRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
}
var DeleteCloudletOptionalArgs = []string{
	"federatedorg",
	"location.latitude",
	"location.longitude",
	"location.altitude",
	"ipsupport",
	"staticips",
	"numdynamicips",
	"timelimits.createclusterinsttimeout",
	"timelimits.updateclusterinsttimeout",
	"timelimits.deleteclusterinsttimeout",
	"timelimits.createappinsttimeout",
	"timelimits.updateappinsttimeout",
	"timelimits.deleteappinsttimeout",
	"crmoverride",
	"deploymentlocal",
	"platformtype",
	"notifysrvaddr",
	"flavor.name",
	"physicalname",
	"envvar",
	"containerversion",
	"accessvars",
	"vmimageversion",
	"deployment",
	"infraapiaccess",
	"infraconfig.externalnetworkname",
	"infraconfig.flavorname",
	"maintenancestate",
	"overridepolicycontainerversion",
	"vmpool",
	"trustpolicy",
	"resourcequotas:#.name",
	"resourcequotas:#.value",
	"resourcequotas:#.alertthreshold",
	"defaultresourcealertthreshold",
	"kafkacluster",
	"kafkauser",
	"kafkapassword",
	"gpuconfig.driver.name",
	"gpuconfig.driver.organization",
	"gpuconfig.properties",
	"gpuconfig.licenseconfig",
	"enabledefaultserverlesscluster",
	"allianceorgs",
	"singlekubernetesclusterowner",
	"platformhighavailability",
	"secondarynotifysrvaddr",
}
var UpdateCloudletRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
}
var UpdateCloudletOptionalArgs = []string{
	"federatedorg",
	"location.latitude",
	"location.longitude",
	"location.altitude",
	"ipsupport",
	"staticips",
	"numdynamicips",
	"timelimits.createclusterinsttimeout",
	"timelimits.updateclusterinsttimeout",
	"timelimits.deleteclusterinsttimeout",
	"timelimits.createappinsttimeout",
	"timelimits.updateappinsttimeout",
	"timelimits.deleteappinsttimeout",
	"crmoverride",
	"notifysrvaddr",
	"envvar",
	"accessvars",
	"maintenancestate",
	"trustpolicy",
	"resourcequotas:empty",
	"resourcequotas:#.name",
	"resourcequotas:#.value",
	"resourcequotas:#.alertthreshold",
	"defaultresourcealertthreshold",
	"kafkacluster",
	"kafkauser",
	"kafkapassword",
	"gpuconfig.driver.name",
	"gpuconfig.driver.organization",
	"gpuconfig.properties",
	"gpuconfig.licenseconfig",
	"enabledefaultserverlesscluster",
	"allianceorgs",
	"singlekubernetesclusterowner",
	"platformhighavailability",
	"secondarynotifysrvaddr",
}
var ShowCloudletRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
}
var ShowCloudletOptionalArgs = []string{
	"federatedorg",
	"location.latitude",
	"location.longitude",
	"location.altitude",
	"ipsupport",
	"staticips",
	"numdynamicips",
	"timelimits.createclusterinsttimeout",
	"timelimits.updateclusterinsttimeout",
	"timelimits.deleteclusterinsttimeout",
	"timelimits.createappinsttimeout",
	"timelimits.updateappinsttimeout",
	"timelimits.deleteappinsttimeout",
	"crmoverride",
	"deploymentlocal",
	"platformtype",
	"notifysrvaddr",
	"flavor.name",
	"physicalname",
	"envvar",
	"containerversion",
	"accessvars",
	"vmimageversion",
	"deployment",
	"infraapiaccess",
	"infraconfig.externalnetworkname",
	"infraconfig.flavorname",
	"maintenancestate",
	"overridepolicycontainerversion",
	"vmpool",
	"trustpolicy",
	"resourcequotas:#.name",
	"resourcequotas:#.value",
	"resourcequotas:#.alertthreshold",
	"defaultresourcealertthreshold",
	"kafkacluster",
	"kafkauser",
	"kafkapassword",
	"gpuconfig.driver.name",
	"gpuconfig.driver.organization",
	"gpuconfig.properties",
	"gpuconfig.licenseconfig",
	"enabledefaultserverlesscluster",
	"allianceorgs",
	"singlekubernetesclusterowner",
	"platformhighavailability",
	"secondarynotifysrvaddr",
}
var GetCloudletPropsRequiredArgs = []string{
	"platformtype",
}
var GetCloudletPropsOptionalArgs = []string{
	"organization",
}
var GetCloudletResourceQuotaPropsRequiredArgs = []string{
	"platformtype",
}
var GetCloudletResourceQuotaPropsOptionalArgs = []string{
	"organization",
}
var GetCloudletResourceUsageRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
}
var GetCloudletResourceUsageOptionalArgs = []string{
	"federatedorg",
	"infrausage",
}
var ShowFlavorsForCloudletRequiredArgs = []string{}
var ShowFlavorsForCloudletOptionalArgs = []string{
	"cloudletorg",
	"cloudlet",
	"federatororg",
}

var ShowCloudletInfoCmd = &ApiCommand{
	Name:         "ShowCloudletInfo",
	Use:          "show",
	Short:        "Show CloudletInfos",
	RequiredArgs: "region",
	OptionalArgs: strings.Join(append(CloudletInfoRequiredArgs, CloudletInfoOptionalArgs...), " "),
	AliasArgs:    strings.Join(CloudletInfoAliasArgs, " "),
	SpecialArgs:  &CloudletInfoSpecialArgs,
	Comments:     addRegionComment(CloudletInfoComments),
	NoConfig:     "Status",
	ReqData:      &ormapi.RegionCloudletInfo{},
	ReplyData:    &edgeproto.CloudletInfo{},
	Path:         "/auth/ctrl/ShowCloudletInfo",
	StreamOut:    true,
	ProtobufApi:  true,
}

var InjectCloudletInfoCmd = &ApiCommand{
	Name:         "InjectCloudletInfo",
	Use:          "inject",
	Short:        "Inject (create) a CloudletInfo for regression testing",
	RequiredArgs: "region " + strings.Join(CloudletInfoRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletInfoOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletInfoAliasArgs, " "),
	SpecialArgs:  &CloudletInfoSpecialArgs,
	Comments:     addRegionComment(CloudletInfoComments),
	NoConfig:     "Status",
	ReqData:      &ormapi.RegionCloudletInfo{},
	ReplyData:    &edgeproto.Result{},
	Path:         "/auth/ctrl/InjectCloudletInfo",
	ProtobufApi:  true,
}

var EvictCloudletInfoCmd = &ApiCommand{
	Name:         "EvictCloudletInfo",
	Use:          "evict",
	Short:        "Evict (delete) a CloudletInfo for regression testing",
	RequiredArgs: "region " + strings.Join(CloudletInfoRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletInfoOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletInfoAliasArgs, " "),
	SpecialArgs:  &CloudletInfoSpecialArgs,
	Comments:     addRegionComment(CloudletInfoComments),
	NoConfig:     "Status",
	ReqData:      &ormapi.RegionCloudletInfo{},
	ReplyData:    &edgeproto.Result{},
	Path:         "/auth/ctrl/EvictCloudletInfo",
	ProtobufApi:  true,
}
var CloudletInfoApiCmds = []*ApiCommand{
	ShowCloudletInfoCmd,
	InjectCloudletInfoCmd,
	EvictCloudletInfoCmd,
}

const CloudletInfoGroup = "CloudletInfo"

func init() {
	AllApis.AddGroup(CloudletInfoGroup, "Manage CloudletInfos", CloudletInfoApiCmds)
}

var CloudletResMapRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
	"mapping",
}
var CloudletResMapOptionalArgs = []string{
	"federatedorg",
}
var CloudletResMapAliasArgs = []string{
	"cloudletorg=cloudletresmap.key.organization",
	"cloudlet=cloudletresmap.key.name",
	"federatedorg=cloudletresmap.key.federatedorganization",
	"mapping=cloudletresmap.mapping",
}
var CloudletResMapComments = map[string]string{
	"cloudletorg":  "Organization of the cloudlet site",
	"cloudlet":     "Name of the cloudlet",
	"federatedorg": "Federated operator organization who shared this cloudlet",
	"mapping":      "Resource mapping info",
}
var CloudletResMapSpecialArgs = map[string]string{
	"cloudletresmap.mapping": "StringToString",
}
var GPUDriverKeyRequiredArgs = []string{}
var GPUDriverKeyOptionalArgs = []string{
	"name",
	"organization",
}
var GPUDriverKeyAliasArgs = []string{
	"name=gpudriverkey.name",
	"organization=gpudriverkey.organization",
}
var GPUDriverKeyComments = map[string]string{
	"name":         "Name of the driver",
	"organization": "Organization to which the driver belongs to",
}
var GPUDriverKeySpecialArgs = map[string]string{}
var GPUDriverBuildMemberRequiredArgs = []string{
	"gpudrivername",
	"gpudriverorg",
}
var GPUDriverBuildMemberOptionalArgs = []string{
	"build.name",
	"build.driverpath",
	"build.driverpathcreds",
	"build.operatingsystem",
	"build.kernelversion",
	"build.hypervisorinfo",
	"build.md5sum",
	"ignorestate",
}
var GPUDriverBuildMemberAliasArgs = []string{
	"gpudrivername=gpudriverbuildmember.key.name",
	"gpudriverorg=gpudriverbuildmember.key.organization",
	"build.name=gpudriverbuildmember.build.name",
	"build.driverpath=gpudriverbuildmember.build.driverpath",
	"build.driverpathcreds=gpudriverbuildmember.build.driverpathcreds",
	"build.operatingsystem=gpudriverbuildmember.build.operatingsystem",
	"build.kernelversion=gpudriverbuildmember.build.kernelversion",
	"build.hypervisorinfo=gpudriverbuildmember.build.hypervisorinfo",
	"build.md5sum=gpudriverbuildmember.build.md5sum",
	"ignorestate=gpudriverbuildmember.ignorestate",
}
var GPUDriverBuildMemberComments = map[string]string{
	"gpudrivername":         "Name of the driver",
	"gpudriverorg":          "Organization to which the driver belongs to",
	"build.name":            "Unique identifier key",
	"build.driverpath":      "Path where the driver package is located, if it is authenticated path, then credentials must be passed as part of URL (one-time download path)",
	"build.driverpathcreds": "Optional credentials (username:password) to access driver path",
	"build.operatingsystem": "Operator System supported by GPU driver build, one of Linux, Windows, Others",
	"build.kernelversion":   "Kernel Version supported by GPU driver build",
	"build.hypervisorinfo":  "Info on hypervisor supported by vGPU driver",
	"build.md5sum":          "Driver package md5sum to ensure package is not corrupted",
	"ignorestate":           "Ignore state will ignore any action in-progress on the GPU driver",
}
var GPUDriverBuildMemberSpecialArgs = map[string]string{}
var GPUDriverRequiredArgs = []string{
	"gpudrivername",
}
var GPUDriverOptionalArgs = []string{
	"gpudriverorg",
	"builds:empty",
	"builds:#.name",
	"builds:#.driverpath",
	"builds:#.driverpathcreds",
	"builds:#.operatingsystem",
	"builds:#.kernelversion",
	"builds:#.hypervisorinfo",
	"builds:#.md5sum",
	"licenseconfig",
	"properties",
	"ignorestate",
}
var GPUDriverAliasArgs = []string{
	"fields=gpudriver.fields",
	"gpudrivername=gpudriver.key.name",
	"gpudriverorg=gpudriver.key.organization",
	"builds:empty=gpudriver.builds:empty",
	"builds:#.name=gpudriver.builds:#.name",
	"builds:#.driverpath=gpudriver.builds:#.driverpath",
	"builds:#.driverpathcreds=gpudriver.builds:#.driverpathcreds",
	"builds:#.operatingsystem=gpudriver.builds:#.operatingsystem",
	"builds:#.kernelversion=gpudriver.builds:#.kernelversion",
	"builds:#.hypervisorinfo=gpudriver.builds:#.hypervisorinfo",
	"builds:#.md5sum=gpudriver.builds:#.md5sum",
	"licenseconfig=gpudriver.licenseconfig",
	"licenseconfigmd5sum=gpudriver.licenseconfigmd5sum",
	"properties=gpudriver.properties",
	"state=gpudriver.state",
	"ignorestate=gpudriver.ignorestate",
	"deleteprepare=gpudriver.deleteprepare",
}
var GPUDriverComments = map[string]string{
	"fields":                   "Fields are used for the Update API to specify which fields to apply",
	"gpudrivername":            "Name of the driver",
	"gpudriverorg":             "Organization to which the driver belongs to",
	"builds:empty":             "List of GPU driver build, specify builds:empty=true to clear",
	"builds:#.name":            "Unique identifier key",
	"builds:#.driverpath":      "Path where the driver package is located, if it is authenticated path, then credentials must be passed as part of URL (one-time download path)",
	"builds:#.driverpathcreds": "Optional credentials (username:password) to access driver path",
	"builds:#.operatingsystem": "Operator System supported by GPU driver build, one of Linux, Windows, Others",
	"builds:#.kernelversion":   "Kernel Version supported by GPU driver build",
	"builds:#.hypervisorinfo":  "Info on hypervisor supported by vGPU driver",
	"builds:#.md5sum":          "Driver package md5sum to ensure package is not corrupted",
	"licenseconfig":            "License config to setup license (will be stored in secure storage)",
	"licenseconfigmd5sum":      "License config md5sum, to ensure integrity of license config",
	"properties":               "Additional properties associated with GPU driver build For example: license server information, driver release date, etc, specify properties:empty=true to clear",
	"state":                    "State to figure out if any action on the GPU driver is in-progress",
	"ignorestate":              "Ignore state will ignore any action in-progress on the GPU driver",
	"deleteprepare":            "Preparing to be deleted",
}
var GPUDriverSpecialArgs = map[string]string{
	"gpudriver.fields":     "StringArray",
	"gpudriver.properties": "StringToString",
}
var CloudletRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
}
var CloudletOptionalArgs = []string{
	"federatedorg",
	"location.latitude",
	"location.longitude",
	"location.altitude",
	"ipsupport",
	"staticips",
	"numdynamicips",
	"timelimits.createclusterinsttimeout",
	"timelimits.updateclusterinsttimeout",
	"timelimits.deleteclusterinsttimeout",
	"timelimits.createappinsttimeout",
	"timelimits.updateappinsttimeout",
	"timelimits.deleteappinsttimeout",
	"crmoverride",
	"deploymentlocal",
	"platformtype",
	"notifysrvaddr",
	"flavor.name",
	"physicalname",
	"envvar",
	"containerversion",
	"accessvars",
	"vmimageversion",
	"deployment",
	"infraapiaccess",
	"infraconfig.externalnetworkname",
	"infraconfig.flavorname",
	"maintenancestate",
	"overridepolicycontainerversion",
	"vmpool",
	"trustpolicy",
	"resourcequotas:empty",
	"resourcequotas:#.name",
	"resourcequotas:#.value",
	"resourcequotas:#.alertthreshold",
	"defaultresourcealertthreshold",
	"kafkacluster",
	"kafkauser",
	"kafkapassword",
	"gpuconfig.driver.name",
	"gpuconfig.driver.organization",
	"gpuconfig.properties",
	"gpuconfig.licenseconfig",
	"enabledefaultserverlesscluster",
	"allianceorgs",
	"singlekubernetesclusterowner",
	"platformhighavailability",
	"secondarynotifysrvaddr",
}
var CloudletAliasArgs = []string{
	"fields=cloudlet.fields",
	"cloudletorg=cloudlet.key.organization",
	"cloudlet=cloudlet.key.name",
	"federatedorg=cloudlet.key.federatedorganization",
	"location.latitude=cloudlet.location.latitude",
	"location.longitude=cloudlet.location.longitude",
	"location.horizontalaccuracy=cloudlet.location.horizontalaccuracy",
	"location.verticalaccuracy=cloudlet.location.verticalaccuracy",
	"location.altitude=cloudlet.location.altitude",
	"location.course=cloudlet.location.course",
	"location.speed=cloudlet.location.speed",
	"location.timestamp=cloudlet.location.timestamp",
	"ipsupport=cloudlet.ipsupport",
	"staticips=cloudlet.staticips",
	"numdynamicips=cloudlet.numdynamicips",
	"timelimits.createclusterinsttimeout=cloudlet.timelimits.createclusterinsttimeout",
	"timelimits.updateclusterinsttimeout=cloudlet.timelimits.updateclusterinsttimeout",
	"timelimits.deleteclusterinsttimeout=cloudlet.timelimits.deleteclusterinsttimeout",
	"timelimits.createappinsttimeout=cloudlet.timelimits.createappinsttimeout",
	"timelimits.updateappinsttimeout=cloudlet.timelimits.updateappinsttimeout",
	"timelimits.deleteappinsttimeout=cloudlet.timelimits.deleteappinsttimeout",
	"errors=cloudlet.errors",
	"state=cloudlet.state",
	"crmoverride=cloudlet.crmoverride",
	"deploymentlocal=cloudlet.deploymentlocal",
	"platformtype=cloudlet.platformtype",
	"notifysrvaddr=cloudlet.notifysrvaddr",
	"flavor.name=cloudlet.flavor.name",
	"physicalname=cloudlet.physicalname",
	"envvar=cloudlet.envvar",
	"containerversion=cloudlet.containerversion",
	"config.containerregistrypath=cloudlet.config.containerregistrypath",
	"config.cloudletvmimagepath=cloudlet.config.cloudletvmimagepath",
	"config.notifyctrladdrs=cloudlet.config.notifyctrladdrs",
	"config.tlscertfile=cloudlet.config.tlscertfile",
	"config.tlskeyfile=cloudlet.config.tlskeyfile",
	"config.tlscafile=cloudlet.config.tlscafile",
	"config.envvar=cloudlet.config.envvar",
	"config.platformtag=cloudlet.config.platformtag",
	"config.testmode=cloudlet.config.testmode",
	"config.span=cloudlet.config.span",
	"config.cleanupmode=cloudlet.config.cleanupmode",
	"config.region=cloudlet.config.region",
	"config.commercialcerts=cloudlet.config.commercialcerts",
	"config.usevaultpki=cloudlet.config.usevaultpki",
	"config.appdnsroot=cloudlet.config.appdnsroot",
	"config.chefserverpath=cloudlet.config.chefserverpath",
	"config.chefclientinterval=cloudlet.config.chefclientinterval",
	"config.deploymenttag=cloudlet.config.deploymenttag",
	"config.crmaccessprivatekey=cloudlet.config.crmaccessprivatekey",
	"config.accessapiaddr=cloudlet.config.accessapiaddr",
	"config.cachedir=cloudlet.config.cachedir",
	"config.secondarycrmaccessprivatekey=cloudlet.config.secondarycrmaccessprivatekey",
	"config.thanosrecvaddr=cloudlet.config.thanosrecvaddr",
	"accessvars=cloudlet.accessvars",
	"vmimageversion=cloudlet.vmimageversion",
	"deployment=cloudlet.deployment",
	"infraapiaccess=cloudlet.infraapiaccess",
	"infraconfig.externalnetworkname=cloudlet.infraconfig.externalnetworkname",
	"infraconfig.flavorname=cloudlet.infraconfig.flavorname",
	"chefclientkey=cloudlet.chefclientkey",
	"maintenancestate=cloudlet.maintenancestate",
	"overridepolicycontainerversion=cloudlet.overridepolicycontainerversion",
	"vmpool=cloudlet.vmpool",
	"crmaccesspublickey=cloudlet.crmaccesspublickey",
	"crmaccesskeyupgraderequired=cloudlet.crmaccesskeyupgraderequired",
	"createdat=cloudlet.createdat",
	"updatedat=cloudlet.updatedat",
	"trustpolicy=cloudlet.trustpolicy",
	"trustpolicystate=cloudlet.trustpolicystate",
	"resourcequotas:empty=cloudlet.resourcequotas:empty",
	"resourcequotas:#.name=cloudlet.resourcequotas:#.name",
	"resourcequotas:#.value=cloudlet.resourcequotas:#.value",
	"resourcequotas:#.alertthreshold=cloudlet.resourcequotas:#.alertthreshold",
	"defaultresourcealertthreshold=cloudlet.defaultresourcealertthreshold",
	"hostcontroller=cloudlet.hostcontroller",
	"kafkacluster=cloudlet.kafkacluster",
	"kafkauser=cloudlet.kafkauser",
	"kafkapassword=cloudlet.kafkapassword",
	"gpuconfig.driver.name=cloudlet.gpuconfig.driver.name",
	"gpuconfig.driver.organization=cloudlet.gpuconfig.driver.organization",
	"gpuconfig.properties=cloudlet.gpuconfig.properties",
	"gpuconfig.licenseconfig=cloudlet.gpuconfig.licenseconfig",
	"gpuconfig.licenseconfigmd5sum=cloudlet.gpuconfig.licenseconfigmd5sum",
	"enabledefaultserverlesscluster=cloudlet.enabledefaultserverlesscluster",
	"allianceorgs=cloudlet.allianceorgs",
	"singlekubernetesclusterowner=cloudlet.singlekubernetesclusterowner",
	"deleteprepare=cloudlet.deleteprepare",
	"platformhighavailability=cloudlet.platformhighavailability",
	"secondarycrmaccesspublickey=cloudlet.secondarycrmaccesspublickey",
	"secondarycrmaccesskeyupgraderequired=cloudlet.secondarycrmaccesskeyupgraderequired",
	"secondarynotifysrvaddr=cloudlet.secondarynotifysrvaddr",
	"dnslabel=cloudlet.dnslabel",
	"rootlbfqdn=cloudlet.rootlbfqdn",
	"federationconfig.federationname=cloudlet.federationconfig.federationname",
	"federationconfig.selffederationid=cloudlet.federationconfig.selffederationid",
	"federationconfig.partnerfederationid=cloudlet.federationconfig.partnerfederationid",
	"federationconfig.zonecountrycode=cloudlet.federationconfig.zonecountrycode",
	"federationconfig.partnerfederationaddr=cloudlet.federationconfig.partnerfederationaddr",
}
var CloudletComments = map[string]string{
	"fields":                                 "Fields are used for the Update API to specify which fields to apply",
	"cloudletorg":                            "Organization of the cloudlet site",
	"cloudlet":                               "Name of the cloudlet",
	"federatedorg":                           "Federated operator organization who shared this cloudlet",
	"location.latitude":                      "Latitude in WGS 84 coordinates",
	"location.longitude":                     "Longitude in WGS 84 coordinates",
	"location.horizontalaccuracy":            "Horizontal accuracy (radius in meters)",
	"location.verticalaccuracy":              "Vertical accuracy (meters)",
	"location.altitude":                      "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"location.course":                        "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"location.speed":                         "Speed (IOS) / velocity (Android) (meters/sec)",
	"location.timestamp":                     "Timestamp",
	"ipsupport":                              "Type of IP support provided by Cloudlet (see IpSupport), one of Unknown, Static, Dynamic",
	"staticips":                              "List of static IPs for static IP support",
	"numdynamicips":                          "Number of dynamic IPs available for dynamic IP support",
	"timelimits.createclusterinsttimeout":    "Override default max time to create a cluster instance (duration)",
	"timelimits.updateclusterinsttimeout":    "Override default max time to update a cluster instance (duration)",
	"timelimits.deleteclusterinsttimeout":    "Override default max time to delete a cluster instance (duration)",
	"timelimits.createappinsttimeout":        "Override default max time to create an app instance (duration)",
	"timelimits.updateappinsttimeout":        "Override default max time to update an app instance (duration)",
	"timelimits.deleteappinsttimeout":        "Override default max time to delete an app instance (duration)",
	"errors":                                 "Any errors trying to create, update, or delete the Cloudlet., specify errors:empty=true to clear",
	"state":                                  "Current state of the cloudlet, one of TrackedStateUnknown, NotPresent, CreateRequested, Creating, CreateError, Ready, UpdateRequested, Updating, UpdateError, DeleteRequested, Deleting, DeleteError, DeletePrepare, CrmInitok, CreatingDependencies, DeleteDone",
	"crmoverride":                            "Override actions to CRM, one of NoOverride, IgnoreCrmErrors, IgnoreCrm, IgnoreTransientState, IgnoreCrmAndTransientState",
	"deploymentlocal":                        "Deploy cloudlet services locally",
	"platformtype":                           "Platform type, one of Fake, Dind, Openstack, Azure, Gcp, Edgebox, Fakeinfra, Vsphere, AwsEks, VmPool, AwsEc2, Vcd, K8SBareMetal, Kind, Kindinfra, FakeSingleCluster, Federation, FakeVmPool",
	"notifysrvaddr":                          "Address for the CRM notify listener to run on",
	"flavor.name":                            "Flavor name",
	"physicalname":                           "Physical infrastructure cloudlet name",
	"envvar":                                 "Single Key-Value pair of env var to be passed to CRM, specify envvar:empty=true to clear",
	"containerversion":                       "Cloudlet container version",
	"config.containerregistrypath":           "Path to Docker registry holding edge-cloud image",
	"config.cloudletvmimagepath":             "Path to platform base image",
	"config.notifyctrladdrs":                 "Address of controller notify port (can be multiple of these)",
	"config.tlscertfile":                     "TLS cert file",
	"config.tlskeyfile":                      "TLS key file",
	"config.tlscafile":                       "TLS ca file",
	"config.envvar":                          "Environment variables, specify config.envvar:empty=true to clear",
	"config.platformtag":                     "Tag of edge-cloud image",
	"config.testmode":                        "Internal Test flag",
	"config.span":                            "Span string",
	"config.cleanupmode":                     "Internal cleanup flag",
	"config.region":                          "Region",
	"config.commercialcerts":                 "Get certs from vault or generate your own for the root load balancer",
	"config.usevaultpki":                     "Use Vault certs and CAs for internal TLS communication",
	"config.appdnsroot":                      "App domain name root",
	"config.chefserverpath":                  "Path to Chef Server",
	"config.chefclientinterval":              "Chef client interval",
	"config.deploymenttag":                   "Deployment Tag",
	"config.crmaccessprivatekey":             "crm access private key",
	"config.accessapiaddr":                   "controller access API address",
	"config.cachedir":                        "cache dir",
	"config.secondarycrmaccessprivatekey":    "secondary crm access private key",
	"config.thanosrecvaddr":                  "Thanos Receive remote write address",
	"accessvars":                             "Variables required to access cloudlet, specify accessvars:empty=true to clear",
	"vmimageversion":                         "MobiledgeX baseimage version where CRM services reside",
	"deployment":                             "Deployment type to bring up CRM services (docker, kubernetes)",
	"infraapiaccess":                         "Infra Access Type is the type of access available to Infra API Endpoint, one of DirectAccess, RestrictedAccess",
	"infraconfig.externalnetworkname":        "Infra specific external network name",
	"infraconfig.flavorname":                 "Infra specific flavor name",
	"chefclientkey":                          "Chef client key, specify chefclientkey:empty=true to clear",
	"maintenancestate":                       "State for maintenance, one of NormalOperation, MaintenanceStart, MaintenanceStartNoFailover",
	"overridepolicycontainerversion":         "Override container version from policy file",
	"vmpool":                                 "VM Pool",
	"crmaccesspublickey":                     "CRM access public key",
	"crmaccesskeyupgraderequired":            "CRM access key upgrade required",
	"createdat":                              "Created at time",
	"updatedat":                              "Updated at time",
	"trustpolicy":                            "Optional Trust Policy",
	"trustpolicystate":                       "State of trust policy, one of TrackedStateUnknown, NotPresent, CreateRequested, Creating, CreateError, Ready, UpdateRequested, Updating, UpdateError, DeleteRequested, Deleting, DeleteError, DeletePrepare, CrmInitok, CreatingDependencies, DeleteDone",
	"resourcequotas:empty":                   "Resource quotas, specify resourcequotas:empty=true to clear",
	"resourcequotas:#.name":                  "Resource name on which to set quota",
	"resourcequotas:#.value":                 "Quota value of the resource",
	"resourcequotas:#.alertthreshold":        "Generate alert when more than threshold percentage of resource is used",
	"defaultresourcealertthreshold":          "Default resource alert threshold percentage",
	"hostcontroller":                         "Address of the controller hosting the cloudlet services if it is running locally",
	"kafkacluster":                           "Operator provided kafka cluster endpoint to push events to",
	"kafkauser":                              "Username for kafka SASL/PLAIN authentification, stored securely in secret storage and never visible externally",
	"kafkapassword":                          "Password for kafka SASL/PLAIN authentification, stored securely in secret storage and never visible externally",
	"gpuconfig.driver.name":                  "Name of the driver",
	"gpuconfig.driver.organization":          "Organization to which the driver belongs to",
	"gpuconfig.properties":                   "Properties to identify specifics of GPU, specify gpuconfig.properties:empty=true to clear",
	"gpuconfig.licenseconfig":                "Cloudlet specific license config to setup license (will be stored in secure storage)",
	"gpuconfig.licenseconfigmd5sum":          "Cloudlet specific license config md5sum, to ensure integrity of license config",
	"enabledefaultserverlesscluster":         "Enable experimental default multitenant (serverless) cluster",
	"allianceorgs":                           "This cloudlet will be treated as directly connected to these additional operator organizations for the purposes of FindCloudlet, specify allianceorgs:empty=true to clear",
	"singlekubernetesclusterowner":           "For single kubernetes cluster cloudlet platforms, cluster is owned by this organization instead of multi-tenant",
	"deleteprepare":                          "Preparing to be deleted",
	"platformhighavailability":               "Enable platform H/A",
	"secondarycrmaccesspublickey":            "CRM secondary access public key for H/A",
	"secondarycrmaccesskeyupgraderequired":   "CRM secondary access key upgrade required for H/A",
	"secondarynotifysrvaddr":                 "Address for the secondary CRM notify listener to run on",
	"dnslabel":                               "DNS label that is unique within the region",
	"rootlbfqdn":                             "Root LB FQDN which is globally unique",
	"federationconfig.federationname":        "Federation name",
	"federationconfig.selffederationid":      "Self federation ID",
	"federationconfig.partnerfederationid":   "Partner federation ID",
	"federationconfig.zonecountrycode":       "Cloudlet zone country code",
	"federationconfig.partnerfederationaddr": "Partner federation address",
}
var CloudletSpecialArgs = map[string]string{
	"cloudlet.accessvars":           "StringToString",
	"cloudlet.allianceorgs":         "StringArray",
	"cloudlet.chefclientkey":        "StringToString",
	"cloudlet.config.envvar":        "StringToString",
	"cloudlet.envvar":               "StringToString",
	"cloudlet.errors":               "StringArray",
	"cloudlet.fields":               "StringArray",
	"cloudlet.gpuconfig.properties": "StringToString",
}
var FlavorMatchRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
	"flavor",
}
var FlavorMatchOptionalArgs = []string{
	"federatedorg",
	"availabilityzone",
}
var FlavorMatchAliasArgs = []string{
	"cloudletorg=flavormatch.key.organization",
	"cloudlet=flavormatch.key.name",
	"federatedorg=flavormatch.key.federatedorganization",
	"flavor=flavormatch.flavorname",
	"availabilityzone=flavormatch.availabilityzone",
}
var FlavorMatchComments = map[string]string{
	"cloudletorg":      "Organization of the cloudlet site",
	"cloudlet":         "Name of the cloudlet",
	"federatedorg":     "Federated operator organization who shared this cloudlet",
	"flavor":           "Flavor name to lookup",
	"availabilityzone": "availability zone for optional resources if any",
}
var FlavorMatchSpecialArgs = map[string]string{}
var CloudletPropsRequiredArgs = []string{}
var CloudletPropsOptionalArgs = []string{
	"platformtype",
	"organization",
}
var CloudletPropsAliasArgs = []string{
	"platformtype=cloudletprops.platformtype",
	"organization=cloudletprops.organization",
}
var CloudletPropsComments = map[string]string{
	"platformtype": "Platform type, one of Fake, Dind, Openstack, Azure, Gcp, Edgebox, Fakeinfra, Vsphere, AwsEks, VmPool, AwsEc2, Vcd, K8SBareMetal, Kind, Kindinfra, FakeSingleCluster, Federation, FakeVmPool",
	"organization": "Organization",
}
var CloudletPropsSpecialArgs = map[string]string{}
var CloudletResourceQuotaPropsRequiredArgs = []string{}
var CloudletResourceQuotaPropsOptionalArgs = []string{
	"platformtype",
	"properties:#.name",
	"properties:#.value",
	"properties:#.inframaxvalue",
	"properties:#.quotamaxvalue",
	"properties:#.description",
	"properties:#.units",
	"properties:#.alertthreshold",
	"organization",
}
var CloudletResourceQuotaPropsAliasArgs = []string{
	"platformtype=cloudletresourcequotaprops.platformtype",
	"properties:#.name=cloudletresourcequotaprops.properties:#.name",
	"properties:#.value=cloudletresourcequotaprops.properties:#.value",
	"properties:#.inframaxvalue=cloudletresourcequotaprops.properties:#.inframaxvalue",
	"properties:#.quotamaxvalue=cloudletresourcequotaprops.properties:#.quotamaxvalue",
	"properties:#.description=cloudletresourcequotaprops.properties:#.description",
	"properties:#.units=cloudletresourcequotaprops.properties:#.units",
	"properties:#.alertthreshold=cloudletresourcequotaprops.properties:#.alertthreshold",
	"organization=cloudletresourcequotaprops.organization",
}
var CloudletResourceQuotaPropsComments = map[string]string{
	"platformtype":                "Platform type, one of Fake, Dind, Openstack, Azure, Gcp, Edgebox, Fakeinfra, Vsphere, AwsEks, VmPool, AwsEc2, Vcd, K8SBareMetal, Kind, Kindinfra, FakeSingleCluster, Federation, FakeVmPool",
	"properties:#.name":           "Resource name",
	"properties:#.value":          "Resource value",
	"properties:#.inframaxvalue":  "Resource infra max value",
	"properties:#.quotamaxvalue":  "Resource quota max value",
	"properties:#.description":    "Resource description",
	"properties:#.units":          "Resource units",
	"properties:#.alertthreshold": "Generate alert when more than threshold percentage of resource is used",
	"organization":                "Organization",
}
var CloudletResourceQuotaPropsSpecialArgs = map[string]string{}
var CloudletResourceUsageRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
}
var CloudletResourceUsageOptionalArgs = []string{
	"federatedorg",
	"infrausage",
	"info:#.name",
	"info:#.value",
	"info:#.inframaxvalue",
	"info:#.quotamaxvalue",
	"info:#.description",
	"info:#.units",
	"info:#.alertthreshold",
}
var CloudletResourceUsageAliasArgs = []string{
	"cloudletorg=cloudletresourceusage.key.organization",
	"cloudlet=cloudletresourceusage.key.name",
	"federatedorg=cloudletresourceusage.key.federatedorganization",
	"infrausage=cloudletresourceusage.infrausage",
	"info:#.name=cloudletresourceusage.info:#.name",
	"info:#.value=cloudletresourceusage.info:#.value",
	"info:#.inframaxvalue=cloudletresourceusage.info:#.inframaxvalue",
	"info:#.quotamaxvalue=cloudletresourceusage.info:#.quotamaxvalue",
	"info:#.description=cloudletresourceusage.info:#.description",
	"info:#.units=cloudletresourceusage.info:#.units",
	"info:#.alertthreshold=cloudletresourceusage.info:#.alertthreshold",
}
var CloudletResourceUsageComments = map[string]string{
	"cloudletorg":           "Organization of the cloudlet site",
	"cloudlet":              "Name of the cloudlet",
	"federatedorg":          "Federated operator organization who shared this cloudlet",
	"infrausage":            "Show Infra based usage",
	"info:#.name":           "Resource name",
	"info:#.value":          "Resource value",
	"info:#.inframaxvalue":  "Resource infra max value",
	"info:#.quotamaxvalue":  "Resource quota max value",
	"info:#.description":    "Resource description",
	"info:#.units":          "Resource units",
	"info:#.alertthreshold": "Generate alert when more than threshold percentage of resource is used",
}
var CloudletResourceUsageSpecialArgs = map[string]string{}
var CloudletAllianceOrgRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
	"organization",
}
var CloudletAllianceOrgOptionalArgs = []string{
	"federatedorg",
}
var CloudletAllianceOrgAliasArgs = []string{
	"cloudletorg=cloudletallianceorg.key.organization",
	"cloudlet=cloudletallianceorg.key.name",
	"federatedorg=cloudletallianceorg.key.federatedorganization",
	"organization=cloudletallianceorg.organization",
}
var CloudletAllianceOrgComments = map[string]string{
	"cloudletorg":  "Organization of the cloudlet site",
	"cloudlet":     "Name of the cloudlet",
	"federatedorg": "Federated operator organization who shared this cloudlet",
	"organization": "Alliance organization",
}
var CloudletAllianceOrgSpecialArgs = map[string]string{}
var CloudletInfoRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
}
var CloudletInfoOptionalArgs = []string{
	"federatedorg",
	"state",
	"notifyid",
	"controller",
	"osmaxram",
	"osmaxvcores",
	"osmaxvolgb",
	"errors",
	"flavors:#.name",
	"flavors:#.vcpus",
	"flavors:#.ram",
	"flavors:#.disk",
	"flavors:#.propmap",
	"containerversion",
	"availabilityzones:#.name",
	"availabilityzones:#.status",
	"osimages:#.name",
	"osimages:#.tags",
	"osimages:#.properties",
	"osimages:#.diskformat",
	"controllercachereceived",
	"maintenancestate",
	"resourcessnapshot.platformvms:#.name",
	"resourcessnapshot.platformvms:#.type",
	"resourcessnapshot.platformvms:#.status",
	"resourcessnapshot.platformvms:#.infraflavor",
	"resourcessnapshot.platformvms:#.ipaddresses:#.externalip",
	"resourcessnapshot.platformvms:#.ipaddresses:#.internalip",
	"resourcessnapshot.platformvms:#.containers:#.name",
	"resourcessnapshot.platformvms:#.containers:#.type",
	"resourcessnapshot.platformvms:#.containers:#.status",
	"resourcessnapshot.platformvms:#.containers:#.clusterip",
	"resourcessnapshot.platformvms:#.containers:#.restarts",
	"resourcessnapshot.info:#.name",
	"resourcessnapshot.info:#.value",
	"resourcessnapshot.info:#.inframaxvalue",
	"resourcessnapshot.info:#.quotamaxvalue",
	"resourcessnapshot.info:#.description",
	"resourcessnapshot.info:#.units",
	"resourcessnapshot.info:#.alertthreshold",
	"resourcessnapshot.clusterinsts:#.clusterkey.name",
	"resourcessnapshot.clusterinsts:#.organization",
	"resourcessnapshot.vmappinsts:#.appkey.organization",
	"resourcessnapshot.vmappinsts:#.appkey.name",
	"resourcessnapshot.vmappinsts:#.appkey.version",
	"resourcessnapshot.vmappinsts:#.clusterinstkey.clusterkey.name",
	"resourcessnapshot.vmappinsts:#.clusterinstkey.organization",
	"resourcessnapshot.k8sappinsts:#.appkey.organization",
	"resourcessnapshot.k8sappinsts:#.appkey.name",
	"resourcessnapshot.k8sappinsts:#.appkey.version",
	"resourcessnapshot.k8sappinsts:#.clusterinstkey.clusterkey.name",
	"resourcessnapshot.k8sappinsts:#.clusterinstkey.organization",
	"trustpolicystate",
	"compatibilityversion",
	"properties",
	"nodeinfos:#.name",
	"activecrminstance",
	"standbycrm",
}
var CloudletInfoAliasArgs = []string{
	"fields=cloudletinfo.fields",
	"cloudletorg=cloudletinfo.key.organization",
	"cloudlet=cloudletinfo.key.name",
	"federatedorg=cloudletinfo.key.federatedorganization",
	"state=cloudletinfo.state",
	"notifyid=cloudletinfo.notifyid",
	"controller=cloudletinfo.controller",
	"osmaxram=cloudletinfo.osmaxram",
	"osmaxvcores=cloudletinfo.osmaxvcores",
	"osmaxvolgb=cloudletinfo.osmaxvolgb",
	"errors=cloudletinfo.errors",
	"flavors:#.name=cloudletinfo.flavors:#.name",
	"flavors:#.vcpus=cloudletinfo.flavors:#.vcpus",
	"flavors:#.ram=cloudletinfo.flavors:#.ram",
	"flavors:#.disk=cloudletinfo.flavors:#.disk",
	"flavors:#.propmap=cloudletinfo.flavors:#.propmap",
	"status.tasknumber=cloudletinfo.status.tasknumber",
	"status.maxtasks=cloudletinfo.status.maxtasks",
	"status.taskname=cloudletinfo.status.taskname",
	"status.stepname=cloudletinfo.status.stepname",
	"status.msgcount=cloudletinfo.status.msgcount",
	"status.msgs=cloudletinfo.status.msgs",
	"containerversion=cloudletinfo.containerversion",
	"availabilityzones:#.name=cloudletinfo.availabilityzones:#.name",
	"availabilityzones:#.status=cloudletinfo.availabilityzones:#.status",
	"osimages:#.name=cloudletinfo.osimages:#.name",
	"osimages:#.tags=cloudletinfo.osimages:#.tags",
	"osimages:#.properties=cloudletinfo.osimages:#.properties",
	"osimages:#.diskformat=cloudletinfo.osimages:#.diskformat",
	"controllercachereceived=cloudletinfo.controllercachereceived",
	"maintenancestate=cloudletinfo.maintenancestate",
	"resourcessnapshot.platformvms:#.name=cloudletinfo.resourcessnapshot.platformvms:#.name",
	"resourcessnapshot.platformvms:#.type=cloudletinfo.resourcessnapshot.platformvms:#.type",
	"resourcessnapshot.platformvms:#.status=cloudletinfo.resourcessnapshot.platformvms:#.status",
	"resourcessnapshot.platformvms:#.infraflavor=cloudletinfo.resourcessnapshot.platformvms:#.infraflavor",
	"resourcessnapshot.platformvms:#.ipaddresses:#.externalip=cloudletinfo.resourcessnapshot.platformvms:#.ipaddresses:#.externalip",
	"resourcessnapshot.platformvms:#.ipaddresses:#.internalip=cloudletinfo.resourcessnapshot.platformvms:#.ipaddresses:#.internalip",
	"resourcessnapshot.platformvms:#.containers:#.name=cloudletinfo.resourcessnapshot.platformvms:#.containers:#.name",
	"resourcessnapshot.platformvms:#.containers:#.type=cloudletinfo.resourcessnapshot.platformvms:#.containers:#.type",
	"resourcessnapshot.platformvms:#.containers:#.status=cloudletinfo.resourcessnapshot.platformvms:#.containers:#.status",
	"resourcessnapshot.platformvms:#.containers:#.clusterip=cloudletinfo.resourcessnapshot.platformvms:#.containers:#.clusterip",
	"resourcessnapshot.platformvms:#.containers:#.restarts=cloudletinfo.resourcessnapshot.platformvms:#.containers:#.restarts",
	"resourcessnapshot.info:#.name=cloudletinfo.resourcessnapshot.info:#.name",
	"resourcessnapshot.info:#.value=cloudletinfo.resourcessnapshot.info:#.value",
	"resourcessnapshot.info:#.inframaxvalue=cloudletinfo.resourcessnapshot.info:#.inframaxvalue",
	"resourcessnapshot.info:#.quotamaxvalue=cloudletinfo.resourcessnapshot.info:#.quotamaxvalue",
	"resourcessnapshot.info:#.description=cloudletinfo.resourcessnapshot.info:#.description",
	"resourcessnapshot.info:#.units=cloudletinfo.resourcessnapshot.info:#.units",
	"resourcessnapshot.info:#.alertthreshold=cloudletinfo.resourcessnapshot.info:#.alertthreshold",
	"resourcessnapshot.clusterinsts:#.clusterkey.name=cloudletinfo.resourcessnapshot.clusterinsts:#.clusterkey.name",
	"resourcessnapshot.clusterinsts:#.organization=cloudletinfo.resourcessnapshot.clusterinsts:#.organization",
	"resourcessnapshot.vmappinsts:#.appkey.organization=cloudletinfo.resourcessnapshot.vmappinsts:#.appkey.organization",
	"resourcessnapshot.vmappinsts:#.appkey.name=cloudletinfo.resourcessnapshot.vmappinsts:#.appkey.name",
	"resourcessnapshot.vmappinsts:#.appkey.version=cloudletinfo.resourcessnapshot.vmappinsts:#.appkey.version",
	"resourcessnapshot.vmappinsts:#.clusterinstkey.clusterkey.name=cloudletinfo.resourcessnapshot.vmappinsts:#.clusterinstkey.clusterkey.name",
	"resourcessnapshot.vmappinsts:#.clusterinstkey.organization=cloudletinfo.resourcessnapshot.vmappinsts:#.clusterinstkey.organization",
	"resourcessnapshot.k8sappinsts:#.appkey.organization=cloudletinfo.resourcessnapshot.k8sappinsts:#.appkey.organization",
	"resourcessnapshot.k8sappinsts:#.appkey.name=cloudletinfo.resourcessnapshot.k8sappinsts:#.appkey.name",
	"resourcessnapshot.k8sappinsts:#.appkey.version=cloudletinfo.resourcessnapshot.k8sappinsts:#.appkey.version",
	"resourcessnapshot.k8sappinsts:#.clusterinstkey.clusterkey.name=cloudletinfo.resourcessnapshot.k8sappinsts:#.clusterinstkey.clusterkey.name",
	"resourcessnapshot.k8sappinsts:#.clusterinstkey.organization=cloudletinfo.resourcessnapshot.k8sappinsts:#.clusterinstkey.organization",
	"trustpolicystate=cloudletinfo.trustpolicystate",
	"compatibilityversion=cloudletinfo.compatibilityversion",
	"properties=cloudletinfo.properties",
	"nodeinfos:#.name=cloudletinfo.nodeinfos:#.name",
	"activecrminstance=cloudletinfo.activecrminstance",
	"standbycrm=cloudletinfo.standbycrm",
}
var CloudletInfoComments = map[string]string{
	"fields":                                 "Fields are used for the Update API to specify which fields to apply",
	"cloudletorg":                            "Organization of the cloudlet site",
	"cloudlet":                               "Name of the cloudlet",
	"federatedorg":                           "Federated operator organization who shared this cloudlet",
	"state":                                  "State of cloudlet, one of Unknown, Errors, Ready, Offline, NotPresent, Init, Upgrade, NeedSync",
	"notifyid":                               "Id of client assigned by server (internal use only)",
	"controller":                             "Connected controller unique id",
	"osmaxram":                               "Maximum Ram in MB on the Cloudlet",
	"osmaxvcores":                            "Maximum number of VCPU cores on the Cloudlet",
	"osmaxvolgb":                             "Maximum amount of disk in GB on the Cloudlet",
	"errors":                                 "Any errors encountered while making changes to the Cloudlet",
	"flavors:#.name":                         "Name of the flavor on the Cloudlet",
	"flavors:#.vcpus":                        "Number of VCPU cores on the Cloudlet",
	"flavors:#.ram":                          "Ram in MB on the Cloudlet",
	"flavors:#.disk":                         "Amount of disk in GB on the Cloudlet",
	"flavors:#.propmap":                      "OS Flavor Properties, if any",
	"containerversion":                       "Cloudlet container version",
	"availabilityzones:#.name":               "OpenStack availability zone name",
	"availabilityzones:#.status":             "OpenStack availability zone status",
	"osimages:#.name":                        "image name",
	"osimages:#.tags":                        "optional tags present on image",
	"osimages:#.properties":                  "image properties/metadata",
	"osimages:#.diskformat":                  "format qcow2, img, etc",
	"controllercachereceived":                "Indicates all controller data has been sent to CRM",
	"maintenancestate":                       "State for maintenance, one of NormalOperation, MaintenanceStart, MaintenanceStartNoFailover",
	"resourcessnapshot.platformvms:#.name":   "Virtual machine name",
	"resourcessnapshot.platformvms:#.type":   "Type can be platform, rootlb, cluster-master, cluster-k8s-node, cluster-docker-node, appvm",
	"resourcessnapshot.platformvms:#.status": "Runtime status of the VM",
	"resourcessnapshot.platformvms:#.infraflavor":                    "Flavor allocated within the cloudlet infrastructure, distinct from the control plane flavor",
	"resourcessnapshot.platformvms:#.ipaddresses:#.externalip":       "External IP address",
	"resourcessnapshot.platformvms:#.ipaddresses:#.internalip":       "Internal IP address",
	"resourcessnapshot.platformvms:#.containers:#.name":              "Name of the container",
	"resourcessnapshot.platformvms:#.containers:#.type":              "Type can be docker or kubernetes",
	"resourcessnapshot.platformvms:#.containers:#.status":            "Runtime status of the container",
	"resourcessnapshot.platformvms:#.containers:#.clusterip":         "IP within the CNI and is applicable to kubernetes only",
	"resourcessnapshot.platformvms:#.containers:#.restarts":          "Restart count, applicable to kubernetes only",
	"resourcessnapshot.info:#.name":                                  "Resource name",
	"resourcessnapshot.info:#.value":                                 "Resource value",
	"resourcessnapshot.info:#.inframaxvalue":                         "Resource infra max value",
	"resourcessnapshot.info:#.quotamaxvalue":                         "Resource quota max value",
	"resourcessnapshot.info:#.description":                           "Resource description",
	"resourcessnapshot.info:#.units":                                 "Resource units",
	"resourcessnapshot.info:#.alertthreshold":                        "Generate alert when more than threshold percentage of resource is used",
	"resourcessnapshot.clusterinsts:#.clusterkey.name":               "Cluster name",
	"resourcessnapshot.clusterinsts:#.organization":                  "Name of Developer organization that this cluster belongs to",
	"resourcessnapshot.vmappinsts:#.appkey.organization":             "App developer organization",
	"resourcessnapshot.vmappinsts:#.appkey.name":                     "App name",
	"resourcessnapshot.vmappinsts:#.appkey.version":                  "App version",
	"resourcessnapshot.vmappinsts:#.clusterinstkey.clusterkey.name":  "Cluster name",
	"resourcessnapshot.vmappinsts:#.clusterinstkey.organization":     "Name of Developer organization that this cluster belongs to",
	"resourcessnapshot.k8sappinsts:#.appkey.organization":            "App developer organization",
	"resourcessnapshot.k8sappinsts:#.appkey.name":                    "App name",
	"resourcessnapshot.k8sappinsts:#.appkey.version":                 "App version",
	"resourcessnapshot.k8sappinsts:#.clusterinstkey.clusterkey.name": "Cluster name",
	"resourcessnapshot.k8sappinsts:#.clusterinstkey.organization":    "Name of Developer organization that this cluster belongs to",
	"trustpolicystate":     "Trust Policy State, one of TrackedStateUnknown, NotPresent, CreateRequested, Creating, CreateError, Ready, UpdateRequested, Updating, UpdateError, DeleteRequested, Deleting, DeleteError, DeletePrepare, CrmInitok, CreatingDependencies, DeleteDone",
	"compatibilityversion": "Version for compatibility tracking",
	"properties":           "Cloudlet properties",
	"nodeinfos:#.name":     "Node name",
	"activecrminstance":    "Active HA instance",
	"standbycrm":           "Denotes if info was reported by inactive",
}
var CloudletInfoSpecialArgs = map[string]string{
	"cloudletinfo.errors":            "StringArray",
	"cloudletinfo.fields":            "StringArray",
	"cloudletinfo.flavors:#.propmap": "StringToString",
	"cloudletinfo.properties":        "StringToString",
	"cloudletinfo.status.msgs":       "StringArray",
}
