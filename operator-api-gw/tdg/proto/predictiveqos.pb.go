// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: predictiveqos.proto

/*
	Package queryqos is a generated protocol buffer package.

	It is generated from these files:
		predictiveqos.proto

	It has these top-level messages:
		QoSKPIRequest
		BandSelection
		PositionKpiResult
		PositionKpiClassificationResult
		PositionKpiRequest
		QoSKPIResponse
		QoSKPIClassificationResponse
		HealthCheckRequest
		HealthCheckResponse
*/
package queryqos

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import "github.com/mobiledgex/edge-cloud/util"
import "errors"
import "strconv"
import "encoding/json"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type HealthCheckResponse_ServingStatus int32

const (
	HealthCheckResponse_UNKNOWN     HealthCheckResponse_ServingStatus = 0
	HealthCheckResponse_SERVING     HealthCheckResponse_ServingStatus = 1
	HealthCheckResponse_NOT_SERVING HealthCheckResponse_ServingStatus = 2
)

var HealthCheckResponse_ServingStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "SERVING",
	2: "NOT_SERVING",
}
var HealthCheckResponse_ServingStatus_value = map[string]int32{
	"UNKNOWN":     0,
	"SERVING":     1,
	"NOT_SERVING": 2,
}

func (x HealthCheckResponse_ServingStatus) String() string {
	return proto.EnumName(HealthCheckResponse_ServingStatus_name, int32(x))
}
func (HealthCheckResponse_ServingStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorPredictiveqos, []int{8, 0}
}

type QoSKPIRequest struct {
	// set by the client (the Unix timestamp when the initial
	// request was in the client, in microseconds) and the
	// server attaches it to each response
	Requestid int64 `protobuf:"varint,1,opt,name=requestid,proto3" json:"requestid,omitempty"`
	// The list of the position-timestamp pairs requested
	Requests []*PositionKpiRequest `protobuf:"bytes,2,rep,name=requests" json:"requests,omitempty"`
	// client's device LTE category number
	Ltecategory int32 `protobuf:"varint,4,opt,name=ltecategory,proto3" json:"ltecategory,omitempty"`
	// Band list used by the client
	Bandselection *BandSelection `protobuf:"bytes,5,opt,name=bandselection" json:"bandselection,omitempty"`
}

func (m *QoSKPIRequest) Reset()                    { *m = QoSKPIRequest{} }
func (m *QoSKPIRequest) String() string            { return proto.CompactTextString(m) }
func (*QoSKPIRequest) ProtoMessage()               {}
func (*QoSKPIRequest) Descriptor() ([]byte, []int) { return fileDescriptorPredictiveqos, []int{0} }

type BandSelection struct {
	// Radio Access Technologies
	RAT2G []string `protobuf:"bytes,1,rep,name=RAT2G" json:"RAT2G,omitempty"`
	RAT3G []string `protobuf:"bytes,2,rep,name=RAT3G" json:"RAT3G,omitempty"`
	RAT4G []string `protobuf:"bytes,3,rep,name=RAT4G" json:"RAT4G,omitempty"`
	RAT5G []string `protobuf:"bytes,4,rep,name=RAT5G" json:"RAT5G,omitempty"`
}

func (m *BandSelection) Reset()                    { *m = BandSelection{} }
func (m *BandSelection) String() string            { return proto.CompactTextString(m) }
func (*BandSelection) ProtoMessage()               {}
func (*BandSelection) Descriptor() ([]byte, []int) { return fileDescriptorPredictiveqos, []int{1} }

// Response object
// contains the calculated KPIs at the given grid
// (represented with lat/long coordinates) at the given timestamp.
// a QoSKPIResponse contains a list of this result object
type PositionKpiResult struct {
	// as set by the client, must be unique within one QoSKPIRequest
	Positionid int64 `protobuf:"varint,1,opt,name=positionid,proto3" json:"positionid,omitempty"`
	// Mbit/s
	DluserthroughputMin float32 `protobuf:"fixed32,2,opt,name=dluserthroughput_min,json=dluserthroughputMin,proto3" json:"dluserthroughput_min,omitempty"`
	DluserthroughputAvg float32 `protobuf:"fixed32,3,opt,name=dluserthroughput_avg,json=dluserthroughputAvg,proto3" json:"dluserthroughput_avg,omitempty"`
	DluserthroughputMax float32 `protobuf:"fixed32,4,opt,name=dluserthroughput_max,json=dluserthroughputMax,proto3" json:"dluserthroughput_max,omitempty"`
	// Mbit/s
	UluserthroughputMin float32 `protobuf:"fixed32,5,opt,name=uluserthroughput_min,json=uluserthroughputMin,proto3" json:"uluserthroughput_min,omitempty"`
	UluserthroughputAvg float32 `protobuf:"fixed32,6,opt,name=uluserthroughput_avg,json=uluserthroughputAvg,proto3" json:"uluserthroughput_avg,omitempty"`
	UluserthroughputMax float32 `protobuf:"fixed32,7,opt,name=uluserthroughput_max,json=uluserthroughputMax,proto3" json:"uluserthroughput_max,omitempty"`
	// ms
	LatencyMin float32 `protobuf:"fixed32,8,opt,name=latency_min,json=latencyMin,proto3" json:"latency_min,omitempty"`
	LatencyAvg float32 `protobuf:"fixed32,9,opt,name=latency_avg,json=latencyAvg,proto3" json:"latency_avg,omitempty"`
	LatencyMax float32 `protobuf:"fixed32,10,opt,name=latency_max,json=latencyMax,proto3" json:"latency_max,omitempty"`
}

func (m *PositionKpiResult) Reset()                    { *m = PositionKpiResult{} }
func (m *PositionKpiResult) String() string            { return proto.CompactTextString(m) }
func (*PositionKpiResult) ProtoMessage()               {}
func (*PositionKpiResult) Descriptor() ([]byte, []int) { return fileDescriptorPredictiveqos, []int{2} }

// Response object
// contains the calculated KPIs at the given grid
// (represented with lat/long coordinates) at the given timestamp.
// a QoSKPIClassificationResponse contains a list of this result object
type PositionKpiClassificationResult struct {
	// as set by the client, must be unique within one QoSKPIRequest
	Positionid            int64 `protobuf:"varint,1,opt,name=positionid,proto3" json:"positionid,omitempty"`
	DluserthroughputClass int32 `protobuf:"varint,2,opt,name=dluserthroughput_class,json=dluserthroughputClass,proto3" json:"dluserthroughput_class,omitempty"`
	UluserthroughputClass int32 `protobuf:"varint,3,opt,name=uluserthroughput_class,json=uluserthroughputClass,proto3" json:"uluserthroughput_class,omitempty"`
	LatencyClass          int32 `protobuf:"varint,4,opt,name=latency_class,json=latencyClass,proto3" json:"latency_class,omitempty"`
}

func (m *PositionKpiClassificationResult) Reset()         { *m = PositionKpiClassificationResult{} }
func (m *PositionKpiClassificationResult) String() string { return proto.CompactTextString(m) }
func (*PositionKpiClassificationResult) ProtoMessage()    {}
func (*PositionKpiClassificationResult) Descriptor() ([]byte, []int) {
	return fileDescriptorPredictiveqos, []int{3}
}

// Request sent by the client for a given grid and a given timestamp
// a QoSKPIRequest contains a list of this objects
type PositionKpiRequest struct {
	// as set by the client, must be unique within one QoSKPIRequest
	Positionid int64 `protobuf:"varint,1,opt,name=positionid,proto3" json:"positionid,omitempty"`
	// as decimal degree, i.e.: 48.1855141 , 11.5613505
	// in wsg84 coordinate system
	// minus number represent south / west coordinate
	Latitude  float32 `protobuf:"fixed32,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude float32 `protobuf:"fixed32,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// UNIX timestamp for which the prediction has to be calculated,in secs
	Timestamp int64 `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// altitude above ground level, in meters
	Altitude float32 `protobuf:"fixed32,6,opt,name=altitude,proto3" json:"altitude,omitempty"`
}

func (m *PositionKpiRequest) Reset()                    { *m = PositionKpiRequest{} }
func (m *PositionKpiRequest) String() string            { return proto.CompactTextString(m) }
func (*PositionKpiRequest) ProtoMessage()               {}
func (*PositionKpiRequest) Descriptor() ([]byte, []int) { return fileDescriptorPredictiveqos, []int{4} }

// This response is sent periodically by the server as a server stream.
// The positions with the already passed timestamps are omitted from the
// renewal responses, and when all of the timestamps are passed, the server
// closes the stream for this request
type QoSKPIResponse struct {
	// set by the client
	// (the Unix timestamp when the initial request was in the client, in microseconds)
	// and the server attaches it to each response
	Requestid int64                `protobuf:"varint,1,opt,name=requestid,proto3" json:"requestid,omitempty"`
	Results   []*PositionKpiResult `protobuf:"bytes,2,rep,name=results" json:"results,omitempty"`
}

func (m *QoSKPIResponse) Reset()                    { *m = QoSKPIResponse{} }
func (m *QoSKPIResponse) String() string            { return proto.CompactTextString(m) }
func (*QoSKPIResponse) ProtoMessage()               {}
func (*QoSKPIResponse) Descriptor() ([]byte, []int) { return fileDescriptorPredictiveqos, []int{5} }

// This response is sent periodically by the server as a server stream.
// The positions with the already passed timestamps are omitted from the
// renewal responses, and when all of the timestamps are passed, the server
// closes the stream for this request
type QoSKPIClassificationResponse struct {
	// set by the client
	// (the Unix timestamp when the initial request was in the client, in microseconds)
	// and the server attaches it to each response
	Requestid int64                              `protobuf:"varint,1,opt,name=requestid,proto3" json:"requestid,omitempty"`
	Results   []*PositionKpiClassificationResult `protobuf:"bytes,2,rep,name=results" json:"results,omitempty"`
}

func (m *QoSKPIClassificationResponse) Reset()         { *m = QoSKPIClassificationResponse{} }
func (m *QoSKPIClassificationResponse) String() string { return proto.CompactTextString(m) }
func (*QoSKPIClassificationResponse) ProtoMessage()    {}
func (*QoSKPIClassificationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorPredictiveqos, []int{6}
}

// Health Check Request
// Used for verifying the service status
type HealthCheckRequest struct {
	Service string `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
}

func (m *HealthCheckRequest) Reset()                    { *m = HealthCheckRequest{} }
func (m *HealthCheckRequest) String() string            { return proto.CompactTextString(m) }
func (*HealthCheckRequest) ProtoMessage()               {}
func (*HealthCheckRequest) Descriptor() ([]byte, []int) { return fileDescriptorPredictiveqos, []int{7} }

// Health Check Response
//   - UNKOWN       - an internal error - the actual reason is specified in the error message
//   - SERVING      - service is up and running
//   - NOT_SERVING  - an internal error, when the API frontend is up but cannot provide the actual results
type HealthCheckResponse struct {
	Status HealthCheckResponse_ServingStatus `protobuf:"varint,1,opt,name=status,proto3,enum=queryqos.HealthCheckResponse_ServingStatus" json:"status,omitempty"`
	// similar to http status codes
	Errorcode int32 `protobuf:"varint,2,opt,name=errorcode,proto3" json:"errorcode,omitempty"`
	// prediction model version used for predicting the response values
	Modelversion string `protobuf:"bytes,3,opt,name=modelversion,proto3" json:"modelversion,omitempty"`
}

func (m *HealthCheckResponse) Reset()                    { *m = HealthCheckResponse{} }
func (m *HealthCheckResponse) String() string            { return proto.CompactTextString(m) }
func (*HealthCheckResponse) ProtoMessage()               {}
func (*HealthCheckResponse) Descriptor() ([]byte, []int) { return fileDescriptorPredictiveqos, []int{8} }

func init() {
	proto.RegisterType((*QoSKPIRequest)(nil), "queryqos.QoSKPIRequest")
	proto.RegisterType((*BandSelection)(nil), "queryqos.BandSelection")
	proto.RegisterType((*PositionKpiResult)(nil), "queryqos.PositionKpiResult")
	proto.RegisterType((*PositionKpiClassificationResult)(nil), "queryqos.PositionKpiClassificationResult")
	proto.RegisterType((*PositionKpiRequest)(nil), "queryqos.PositionKpiRequest")
	proto.RegisterType((*QoSKPIResponse)(nil), "queryqos.QoSKPIResponse")
	proto.RegisterType((*QoSKPIClassificationResponse)(nil), "queryqos.QoSKPIClassificationResponse")
	proto.RegisterType((*HealthCheckRequest)(nil), "queryqos.HealthCheckRequest")
	proto.RegisterType((*HealthCheckResponse)(nil), "queryqos.HealthCheckResponse")
	proto.RegisterEnum("queryqos.HealthCheckResponse_ServingStatus", HealthCheckResponse_ServingStatus_name, HealthCheckResponse_ServingStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for QueryQoS service

type QueryQoSClient interface {
	QueryQoSKPI(ctx context.Context, in *QoSKPIRequest, opts ...grpc.CallOption) (QueryQoS_QueryQoSKPIClient, error)
	QueryQoSKPIClassifier(ctx context.Context, in *QoSKPIRequest, opts ...grpc.CallOption) (QueryQoS_QueryQoSKPIClassifierClient, error)
}

type queryQoSClient struct {
	cc *grpc.ClientConn
}

func NewQueryQoSClient(cc *grpc.ClientConn) QueryQoSClient {
	return &queryQoSClient{cc}
}

func (c *queryQoSClient) QueryQoSKPI(ctx context.Context, in *QoSKPIRequest, opts ...grpc.CallOption) (QueryQoS_QueryQoSKPIClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_QueryQoS_serviceDesc.Streams[0], c.cc, "/queryqos.QueryQoS/QueryQoSKPI", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryQoSQueryQoSKPIClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryQoS_QueryQoSKPIClient interface {
	Recv() (*QoSKPIResponse, error)
	grpc.ClientStream
}

type queryQoSQueryQoSKPIClient struct {
	grpc.ClientStream
}

func (x *queryQoSQueryQoSKPIClient) Recv() (*QoSKPIResponse, error) {
	m := new(QoSKPIResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryQoSClient) QueryQoSKPIClassifier(ctx context.Context, in *QoSKPIRequest, opts ...grpc.CallOption) (QueryQoS_QueryQoSKPIClassifierClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_QueryQoS_serviceDesc.Streams[1], c.cc, "/queryqos.QueryQoS/QueryQoSKPIClassifier", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryQoSQueryQoSKPIClassifierClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryQoS_QueryQoSKPIClassifierClient interface {
	Recv() (*QoSKPIClassificationResponse, error)
	grpc.ClientStream
}

type queryQoSQueryQoSKPIClassifierClient struct {
	grpc.ClientStream
}

func (x *queryQoSQueryQoSKPIClassifierClient) Recv() (*QoSKPIClassificationResponse, error) {
	m := new(QoSKPIClassificationResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for QueryQoS service

type QueryQoSServer interface {
	QueryQoSKPI(*QoSKPIRequest, QueryQoS_QueryQoSKPIServer) error
	QueryQoSKPIClassifier(*QoSKPIRequest, QueryQoS_QueryQoSKPIClassifierServer) error
}

func RegisterQueryQoSServer(s *grpc.Server, srv QueryQoSServer) {
	s.RegisterService(&_QueryQoS_serviceDesc, srv)
}

func _QueryQoS_QueryQoSKPI_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QoSKPIRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryQoSServer).QueryQoSKPI(m, &queryQoSQueryQoSKPIServer{stream})
}

type QueryQoS_QueryQoSKPIServer interface {
	Send(*QoSKPIResponse) error
	grpc.ServerStream
}

type queryQoSQueryQoSKPIServer struct {
	grpc.ServerStream
}

func (x *queryQoSQueryQoSKPIServer) Send(m *QoSKPIResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _QueryQoS_QueryQoSKPIClassifier_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QoSKPIRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryQoSServer).QueryQoSKPIClassifier(m, &queryQoSQueryQoSKPIClassifierServer{stream})
}

type QueryQoS_QueryQoSKPIClassifierServer interface {
	Send(*QoSKPIClassificationResponse) error
	grpc.ServerStream
}

type queryQoSQueryQoSKPIClassifierServer struct {
	grpc.ServerStream
}

func (x *queryQoSQueryQoSKPIClassifierServer) Send(m *QoSKPIClassificationResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _QueryQoS_serviceDesc = grpc.ServiceDesc{
	ServiceName: "queryqos.QueryQoS",
	HandlerType: (*QueryQoSServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "QueryQoSKPI",
			Handler:       _QueryQoS_QueryQoSKPI_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "QueryQoSKPIClassifier",
			Handler:       _QueryQoS_QueryQoSKPIClassifier_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "predictiveqos.proto",
}

// Client API for Health service

type HealthClient interface {
	Check(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type healthClient struct {
	cc *grpc.ClientConn
}

func NewHealthClient(cc *grpc.ClientConn) HealthClient {
	return &healthClient{cc}
}

func (c *healthClient) Check(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	out := new(HealthCheckResponse)
	err := grpc.Invoke(ctx, "/queryqos.Health/Check", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Health service

type HealthServer interface {
	Check(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
}

func RegisterHealthServer(s *grpc.Server, srv HealthServer) {
	s.RegisterService(&_Health_serviceDesc, srv)
}

func _Health_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryqos.Health/Check",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServer).Check(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Health_serviceDesc = grpc.ServiceDesc{
	ServiceName: "queryqos.Health",
	HandlerType: (*HealthServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Check",
			Handler:    _Health_Check_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "predictiveqos.proto",
}

func (m *QoSKPIRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QoSKPIRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Requestid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(m.Requestid))
	}
	if len(m.Requests) > 0 {
		for _, msg := range m.Requests {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPredictiveqos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ltecategory != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(m.Ltecategory))
	}
	if m.Bandselection != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(m.Bandselection.Size()))
		n1, err := m.Bandselection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *BandSelection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BandSelection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RAT2G) > 0 {
		for _, s := range m.RAT2G {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RAT3G) > 0 {
		for _, s := range m.RAT3G {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RAT4G) > 0 {
		for _, s := range m.RAT4G {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RAT5G) > 0 {
		for _, s := range m.RAT5G {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *PositionKpiResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionKpiResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Positionid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(m.Positionid))
	}
	if m.DluserthroughputMin != 0 {
		dAtA[i] = 0x15
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DluserthroughputMin))))
		i += 4
	}
	if m.DluserthroughputAvg != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DluserthroughputAvg))))
		i += 4
	}
	if m.DluserthroughputMax != 0 {
		dAtA[i] = 0x25
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DluserthroughputMax))))
		i += 4
	}
	if m.UluserthroughputMin != 0 {
		dAtA[i] = 0x2d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UluserthroughputMin))))
		i += 4
	}
	if m.UluserthroughputAvg != 0 {
		dAtA[i] = 0x35
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UluserthroughputAvg))))
		i += 4
	}
	if m.UluserthroughputMax != 0 {
		dAtA[i] = 0x3d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UluserthroughputMax))))
		i += 4
	}
	if m.LatencyMin != 0 {
		dAtA[i] = 0x45
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LatencyMin))))
		i += 4
	}
	if m.LatencyAvg != 0 {
		dAtA[i] = 0x4d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LatencyAvg))))
		i += 4
	}
	if m.LatencyMax != 0 {
		dAtA[i] = 0x55
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LatencyMax))))
		i += 4
	}
	return i, nil
}

func (m *PositionKpiClassificationResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionKpiClassificationResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Positionid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(m.Positionid))
	}
	if m.DluserthroughputClass != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(m.DluserthroughputClass))
	}
	if m.UluserthroughputClass != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(m.UluserthroughputClass))
	}
	if m.LatencyClass != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(m.LatencyClass))
	}
	return i, nil
}

func (m *PositionKpiRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionKpiRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Positionid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(m.Positionid))
	}
	if m.Latitude != 0 {
		dAtA[i] = 0x15
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
		i += 4
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
		i += 4
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(m.Timestamp))
	}
	if m.Altitude != 0 {
		dAtA[i] = 0x35
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Altitude))))
		i += 4
	}
	return i, nil
}

func (m *QoSKPIResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QoSKPIResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Requestid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(m.Requestid))
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPredictiveqos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QoSKPIClassificationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QoSKPIClassificationResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Requestid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(m.Requestid))
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPredictiveqos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HealthCheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheckRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Service) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(len(m.Service)))
		i += copy(dAtA[i:], m.Service)
	}
	return i, nil
}

func (m *HealthCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(m.Status))
	}
	if m.Errorcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(m.Errorcode))
	}
	if len(m.Modelversion) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPredictiveqos(dAtA, i, uint64(len(m.Modelversion)))
		i += copy(dAtA[i:], m.Modelversion)
	}
	return i, nil
}

func encodeVarintPredictiveqos(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *QoSKPIRequest) CopyInFields(src *QoSKPIRequest) {
	m.Requestid = src.Requestid
	if src.Requests != nil {
		if m.Requests == nil || len(m.Requests) != len(src.Requests) {
			m.Requests = make([]*PositionKpiRequest, len(src.Requests))
		}
		for i0 := 0; i0 < len(src.Requests); i0++ {
			m.Requests[i0] = &PositionKpiRequest{}
			m.Requests[i0].Positionid = src.Requests[i0].Positionid
			m.Requests[i0].Latitude = src.Requests[i0].Latitude
			m.Requests[i0].Longitude = src.Requests[i0].Longitude
			m.Requests[i0].Timestamp = src.Requests[i0].Timestamp
			m.Requests[i0].Altitude = src.Requests[i0].Altitude
		}
	}
	m.Ltecategory = src.Ltecategory
	if src.Bandselection != nil {
		m.Bandselection = &BandSelection{}
		if m.Bandselection.RAT2G == nil || len(m.Bandselection.RAT2G) != len(src.Bandselection.RAT2G) {
			m.Bandselection.RAT2G = make([]string, len(src.Bandselection.RAT2G))
		}
		copy(m.Bandselection.RAT2G, src.Bandselection.RAT2G)
		if m.Bandselection.RAT3G == nil || len(m.Bandselection.RAT3G) != len(src.Bandselection.RAT3G) {
			m.Bandselection.RAT3G = make([]string, len(src.Bandselection.RAT3G))
		}
		copy(m.Bandselection.RAT3G, src.Bandselection.RAT3G)
		if m.Bandselection.RAT4G == nil || len(m.Bandselection.RAT4G) != len(src.Bandselection.RAT4G) {
			m.Bandselection.RAT4G = make([]string, len(src.Bandselection.RAT4G))
		}
		copy(m.Bandselection.RAT4G, src.Bandselection.RAT4G)
		if m.Bandselection.RAT5G == nil || len(m.Bandselection.RAT5G) != len(src.Bandselection.RAT5G) {
			m.Bandselection.RAT5G = make([]string, len(src.Bandselection.RAT5G))
		}
		copy(m.Bandselection.RAT5G, src.Bandselection.RAT5G)
	}
}

// Helper method to check that enums have valid values
func (m *QoSKPIRequest) ValidateEnums() error {
	for _, e := range m.Requests {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if err := m.Bandselection.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (m *BandSelection) CopyInFields(src *BandSelection) {
	if m.RAT2G == nil || len(m.RAT2G) != len(src.RAT2G) {
		m.RAT2G = make([]string, len(src.RAT2G))
	}
	copy(m.RAT2G, src.RAT2G)
	if m.RAT3G == nil || len(m.RAT3G) != len(src.RAT3G) {
		m.RAT3G = make([]string, len(src.RAT3G))
	}
	copy(m.RAT3G, src.RAT3G)
	if m.RAT4G == nil || len(m.RAT4G) != len(src.RAT4G) {
		m.RAT4G = make([]string, len(src.RAT4G))
	}
	copy(m.RAT4G, src.RAT4G)
	if m.RAT5G == nil || len(m.RAT5G) != len(src.RAT5G) {
		m.RAT5G = make([]string, len(src.RAT5G))
	}
	copy(m.RAT5G, src.RAT5G)
}

// Helper method to check that enums have valid values
func (m *BandSelection) ValidateEnums() error {
	return nil
}

func (m *PositionKpiResult) CopyInFields(src *PositionKpiResult) {
	m.Positionid = src.Positionid
	m.DluserthroughputMin = src.DluserthroughputMin
	m.DluserthroughputAvg = src.DluserthroughputAvg
	m.DluserthroughputMax = src.DluserthroughputMax
	m.UluserthroughputMin = src.UluserthroughputMin
	m.UluserthroughputAvg = src.UluserthroughputAvg
	m.UluserthroughputMax = src.UluserthroughputMax
	m.LatencyMin = src.LatencyMin
	m.LatencyAvg = src.LatencyAvg
	m.LatencyMax = src.LatencyMax
}

// Helper method to check that enums have valid values
func (m *PositionKpiResult) ValidateEnums() error {
	return nil
}

func (m *PositionKpiClassificationResult) CopyInFields(src *PositionKpiClassificationResult) {
	m.Positionid = src.Positionid
	m.DluserthroughputClass = src.DluserthroughputClass
	m.UluserthroughputClass = src.UluserthroughputClass
	m.LatencyClass = src.LatencyClass
}

// Helper method to check that enums have valid values
func (m *PositionKpiClassificationResult) ValidateEnums() error {
	return nil
}

func (m *PositionKpiRequest) CopyInFields(src *PositionKpiRequest) {
	m.Positionid = src.Positionid
	m.Latitude = src.Latitude
	m.Longitude = src.Longitude
	m.Timestamp = src.Timestamp
	m.Altitude = src.Altitude
}

// Helper method to check that enums have valid values
func (m *PositionKpiRequest) ValidateEnums() error {
	return nil
}

func (m *QoSKPIResponse) CopyInFields(src *QoSKPIResponse) {
	m.Requestid = src.Requestid
	if src.Results != nil {
		if m.Results == nil || len(m.Results) != len(src.Results) {
			m.Results = make([]*PositionKpiResult, len(src.Results))
		}
		for i0 := 0; i0 < len(src.Results); i0++ {
			m.Results[i0] = &PositionKpiResult{}
			m.Results[i0].Positionid = src.Results[i0].Positionid
			m.Results[i0].DluserthroughputMin = src.Results[i0].DluserthroughputMin
			m.Results[i0].DluserthroughputAvg = src.Results[i0].DluserthroughputAvg
			m.Results[i0].DluserthroughputMax = src.Results[i0].DluserthroughputMax
			m.Results[i0].UluserthroughputMin = src.Results[i0].UluserthroughputMin
			m.Results[i0].UluserthroughputAvg = src.Results[i0].UluserthroughputAvg
			m.Results[i0].UluserthroughputMax = src.Results[i0].UluserthroughputMax
			m.Results[i0].LatencyMin = src.Results[i0].LatencyMin
			m.Results[i0].LatencyAvg = src.Results[i0].LatencyAvg
			m.Results[i0].LatencyMax = src.Results[i0].LatencyMax
		}
	}
}

// Helper method to check that enums have valid values
func (m *QoSKPIResponse) ValidateEnums() error {
	for _, e := range m.Results {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *QoSKPIClassificationResponse) CopyInFields(src *QoSKPIClassificationResponse) {
	m.Requestid = src.Requestid
	if src.Results != nil {
		if m.Results == nil || len(m.Results) != len(src.Results) {
			m.Results = make([]*PositionKpiClassificationResult, len(src.Results))
		}
		for i0 := 0; i0 < len(src.Results); i0++ {
			m.Results[i0] = &PositionKpiClassificationResult{}
			m.Results[i0].Positionid = src.Results[i0].Positionid
			m.Results[i0].DluserthroughputClass = src.Results[i0].DluserthroughputClass
			m.Results[i0].UluserthroughputClass = src.Results[i0].UluserthroughputClass
			m.Results[i0].LatencyClass = src.Results[i0].LatencyClass
		}
	}
}

// Helper method to check that enums have valid values
func (m *QoSKPIClassificationResponse) ValidateEnums() error {
	for _, e := range m.Results {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (m *HealthCheckRequest) CopyInFields(src *HealthCheckRequest) {
	m.Service = src.Service
}

// Helper method to check that enums have valid values
func (m *HealthCheckRequest) ValidateEnums() error {
	return nil
}

func (m *HealthCheckResponse) CopyInFields(src *HealthCheckResponse) {
	m.Status = src.Status
	m.Errorcode = src.Errorcode
	m.Modelversion = src.Modelversion
}

// Helper method to check that enums have valid values
func (m *HealthCheckResponse) ValidateEnums() error {
	if _, ok := HealthCheckResponse_ServingStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	return nil
}

var ServingStatusStrings = []string{
	"UNKNOWN",
	"SERVING",
	"NOT_SERVING",
}

const (
	ServingStatusUNKNOWN     uint64 = 1 << 0
	ServingStatusSERVING     uint64 = 1 << 1
	ServingStatusNOT_SERVING uint64 = 1 << 2
)

var HealthCheckResponse_ServingStatus_CamelName = map[int32]string{
	// UNKNOWN -> Unknown
	0: "Unknown",
	// SERVING -> Serving
	1: "Serving",
	// NOT_SERVING -> NotServing
	2: "NotServing",
}
var HealthCheckResponse_ServingStatus_CamelValue = map[string]int32{
	"Unknown":    0,
	"Serving":    1,
	"NotServing": 2,
}

func (e *HealthCheckResponse_ServingStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, ok := HealthCheckResponse_ServingStatus_CamelValue[util.CamelCase(str)]
	if !ok {
		// may be enum value instead of string
		ival, err := strconv.Atoi(str)
		val = int32(ival)
		if err == nil {
			_, ok = HealthCheckResponse_ServingStatus_CamelName[val]
		}
	}
	if !ok {
		return errors.New(fmt.Sprintf("No enum value for %s", str))
	}
	*e = HealthCheckResponse_ServingStatus(val)
	return nil
}

func (e HealthCheckResponse_ServingStatus) MarshalYAML() (interface{}, error) {
	return proto.EnumName(HealthCheckResponse_ServingStatus_CamelName, int32(e)), nil
}

// custom JSON encoding/decoding
func (e *HealthCheckResponse_ServingStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, ok := HealthCheckResponse_ServingStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = HealthCheckResponse_ServingStatus_CamelName[val]
			}
		}
		if !ok {
			return errors.New(fmt.Sprintf("No enum value for %s", str))
		}
		*e = HealthCheckResponse_ServingStatus(val)
		return nil
	}
	var val int32
	err = json.Unmarshal(b, &val)
	if err == nil {
		*e = HealthCheckResponse_ServingStatus(val)
		return nil
	}
	return fmt.Errorf("No enum value for %v", b)
}

type MatchOptions struct {
	// Filter will ignore 0 or nil fields on the passed in object
	Filter bool
	// IgnoreBackend will ignore fields that were marked backend in .proto
	IgnoreBackend bool
	// Sort repeated (arrays) of Key objects so matching does not
	// fail due to order.
	SortArrayedKeys bool
}

type MatchOpt func(*MatchOptions)

func MatchFilter() MatchOpt {
	return func(opts *MatchOptions) {
		opts.Filter = true
	}
}

func MatchIgnoreBackend() MatchOpt {
	return func(opts *MatchOptions) {
		opts.IgnoreBackend = true
	}
}

func MatchSortArrayedKeys() MatchOpt {
	return func(opts *MatchOptions) {
		opts.SortArrayedKeys = true
	}
}

func applyMatchOptions(opts *MatchOptions, args ...MatchOpt) {
	for _, f := range args {
		f(opts)
	}
}

// DecodeHook for use with the mapstructure package.
// Allows decoding to handle protobuf enums that are
// represented as strings.
func EnumDecodeHook(from, to reflect.Type, data interface{}) (interface{}, error) {
	if from.Kind() != reflect.String {
		return data, nil
	}
	switch to {
	}
	return data, nil
}

func (m *QoSKPIRequest) Size() (n int) {
	var l int
	_ = l
	if m.Requestid != 0 {
		n += 1 + sovPredictiveqos(uint64(m.Requestid))
	}
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovPredictiveqos(uint64(l))
		}
	}
	if m.Ltecategory != 0 {
		n += 1 + sovPredictiveqos(uint64(m.Ltecategory))
	}
	if m.Bandselection != nil {
		l = m.Bandselection.Size()
		n += 1 + l + sovPredictiveqos(uint64(l))
	}
	return n
}

func (m *BandSelection) Size() (n int) {
	var l int
	_ = l
	if len(m.RAT2G) > 0 {
		for _, s := range m.RAT2G {
			l = len(s)
			n += 1 + l + sovPredictiveqos(uint64(l))
		}
	}
	if len(m.RAT3G) > 0 {
		for _, s := range m.RAT3G {
			l = len(s)
			n += 1 + l + sovPredictiveqos(uint64(l))
		}
	}
	if len(m.RAT4G) > 0 {
		for _, s := range m.RAT4G {
			l = len(s)
			n += 1 + l + sovPredictiveqos(uint64(l))
		}
	}
	if len(m.RAT5G) > 0 {
		for _, s := range m.RAT5G {
			l = len(s)
			n += 1 + l + sovPredictiveqos(uint64(l))
		}
	}
	return n
}

func (m *PositionKpiResult) Size() (n int) {
	var l int
	_ = l
	if m.Positionid != 0 {
		n += 1 + sovPredictiveqos(uint64(m.Positionid))
	}
	if m.DluserthroughputMin != 0 {
		n += 5
	}
	if m.DluserthroughputAvg != 0 {
		n += 5
	}
	if m.DluserthroughputMax != 0 {
		n += 5
	}
	if m.UluserthroughputMin != 0 {
		n += 5
	}
	if m.UluserthroughputAvg != 0 {
		n += 5
	}
	if m.UluserthroughputMax != 0 {
		n += 5
	}
	if m.LatencyMin != 0 {
		n += 5
	}
	if m.LatencyAvg != 0 {
		n += 5
	}
	if m.LatencyMax != 0 {
		n += 5
	}
	return n
}

func (m *PositionKpiClassificationResult) Size() (n int) {
	var l int
	_ = l
	if m.Positionid != 0 {
		n += 1 + sovPredictiveqos(uint64(m.Positionid))
	}
	if m.DluserthroughputClass != 0 {
		n += 1 + sovPredictiveqos(uint64(m.DluserthroughputClass))
	}
	if m.UluserthroughputClass != 0 {
		n += 1 + sovPredictiveqos(uint64(m.UluserthroughputClass))
	}
	if m.LatencyClass != 0 {
		n += 1 + sovPredictiveqos(uint64(m.LatencyClass))
	}
	return n
}

func (m *PositionKpiRequest) Size() (n int) {
	var l int
	_ = l
	if m.Positionid != 0 {
		n += 1 + sovPredictiveqos(uint64(m.Positionid))
	}
	if m.Latitude != 0 {
		n += 5
	}
	if m.Longitude != 0 {
		n += 5
	}
	if m.Timestamp != 0 {
		n += 1 + sovPredictiveqos(uint64(m.Timestamp))
	}
	if m.Altitude != 0 {
		n += 5
	}
	return n
}

func (m *QoSKPIResponse) Size() (n int) {
	var l int
	_ = l
	if m.Requestid != 0 {
		n += 1 + sovPredictiveqos(uint64(m.Requestid))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovPredictiveqos(uint64(l))
		}
	}
	return n
}

func (m *QoSKPIClassificationResponse) Size() (n int) {
	var l int
	_ = l
	if m.Requestid != 0 {
		n += 1 + sovPredictiveqos(uint64(m.Requestid))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovPredictiveqos(uint64(l))
		}
	}
	return n
}

func (m *HealthCheckRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovPredictiveqos(uint64(l))
	}
	return n
}

func (m *HealthCheckResponse) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovPredictiveqos(uint64(m.Status))
	}
	if m.Errorcode != 0 {
		n += 1 + sovPredictiveqos(uint64(m.Errorcode))
	}
	l = len(m.Modelversion)
	if l > 0 {
		n += 1 + l + sovPredictiveqos(uint64(l))
	}
	return n
}

func sovPredictiveqos(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPredictiveqos(x uint64) (n int) {
	return sovPredictiveqos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QoSKPIRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictiveqos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QoSKPIRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QoSKPIRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requestid", wireType)
			}
			m.Requestid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Requestid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, &PositionKpiRequest{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ltecategory", wireType)
			}
			m.Ltecategory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ltecategory |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandselection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bandselection == nil {
				m.Bandselection = &BandSelection{}
			}
			if err := m.Bandselection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictiveqos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BandSelection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictiveqos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BandSelection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BandSelection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RAT2G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RAT2G = append(m.RAT2G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RAT3G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RAT3G = append(m.RAT3G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RAT4G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RAT4G = append(m.RAT4G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RAT5G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RAT5G = append(m.RAT5G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictiveqos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionKpiResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictiveqos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionKpiResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionKpiResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positionid", wireType)
			}
			m.Positionid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Positionid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DluserthroughputMin = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputAvg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DluserthroughputAvg = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DluserthroughputMax = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UluserthroughputMin = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputAvg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UluserthroughputAvg = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UluserthroughputMax = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LatencyMin = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyAvg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LatencyAvg = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LatencyMax = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPredictiveqos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionKpiClassificationResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictiveqos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionKpiClassificationResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionKpiClassificationResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positionid", wireType)
			}
			m.Positionid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Positionid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputClass", wireType)
			}
			m.DluserthroughputClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DluserthroughputClass |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputClass", wireType)
			}
			m.UluserthroughputClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UluserthroughputClass |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyClass", wireType)
			}
			m.LatencyClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatencyClass |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPredictiveqos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionKpiRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictiveqos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionKpiRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionKpiRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positionid", wireType)
			}
			m.Positionid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Positionid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Altitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Altitude = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPredictiveqos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QoSKPIResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictiveqos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QoSKPIResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QoSKPIResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requestid", wireType)
			}
			m.Requestid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Requestid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &PositionKpiResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictiveqos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QoSKPIClassificationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictiveqos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QoSKPIClassificationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QoSKPIClassificationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requestid", wireType)
			}
			m.Requestid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Requestid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &PositionKpiClassificationResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictiveqos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictiveqos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictiveqos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictiveqos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (HealthCheckResponse_ServingStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modelversion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modelversion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictiveqos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictiveqos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPredictiveqos(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPredictiveqos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPredictiveqos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPredictiveqos
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPredictiveqos
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPredictiveqos(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPredictiveqos = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPredictiveqos   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("predictiveqos.proto", fileDescriptorPredictiveqos) }

var fileDescriptorPredictiveqos = []byte{
	// 792 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0xee, 0xc4, 0xcd, 0xaf, 0x97, 0xcd, 0xb2, 0x4c, 0x76, 0xc1, 0x5a, 0x42, 0x36, 0x32, 0x12,
	0x0a, 0x42, 0x44, 0x90, 0x6e, 0x24, 0x84, 0xc4, 0xa1, 0x4d, 0x51, 0xa8, 0x22, 0xd2, 0xc4, 0x29,
	0x70, 0x41, 0xaa, 0xa6, 0xf6, 0xe0, 0x58, 0x38, 0x9e, 0xc4, 0x33, 0x8e, 0xd2, 0x23, 0xff, 0x0d,
	0x27, 0xfe, 0x8e, 0x1c, 0x39, 0x70, 0xe0, 0x08, 0xfd, 0x4b, 0xd0, 0x8c, 0xed, 0x24, 0x4e, 0x9c,
	0x6d, 0x6f, 0x9e, 0xef, 0xbd, 0xef, 0x7b, 0xdf, 0xcc, 0x1b, 0xbf, 0x81, 0xda, 0x3c, 0xa0, 0xb6,
	0x6b, 0x09, 0x77, 0x49, 0x17, 0x8c, 0xb7, 0xe7, 0x01, 0x13, 0x0c, 0x97, 0x16, 0x21, 0x0d, 0xee,
	0x17, 0x8c, 0x1b, 0x6b, 0x04, 0xd5, 0x31, 0x9b, 0x0c, 0x46, 0x57, 0x26, 0x5d, 0x84, 0x94, 0x0b,
	0x5c, 0x87, 0x72, 0x10, 0x7d, 0xba, 0xb6, 0x8e, 0x9a, 0xa8, 0xa5, 0x99, 0x5b, 0x00, 0x7f, 0x0d,
	0xa5, 0x78, 0xc1, 0xf5, 0x5c, 0x53, 0x6b, 0x55, 0x3a, 0xf5, 0x76, 0x22, 0xd6, 0x1e, 0x31, 0xee,
	0x0a, 0x97, 0xf9, 0x83, 0xb9, 0x1b, 0xab, 0x99, 0x9b, 0x6c, 0xdc, 0x84, 0x8a, 0x27, 0xa8, 0x45,
	0x04, 0x75, 0x58, 0x70, 0xaf, 0x9f, 0x36, 0x51, 0x2b, 0x6f, 0xee, 0x42, 0xf8, 0x5b, 0xa8, 0xde,
	0x11, 0xdf, 0xe6, 0xd4, 0xa3, 0x96, 0x94, 0xd1, 0xf3, 0x4d, 0xd4, 0xaa, 0x74, 0x3e, 0xdc, 0x16,
	0xb8, 0x20, 0xbe, 0x3d, 0x49, 0xc2, 0x66, 0x3a, 0xdb, 0x70, 0xa0, 0x9a, 0x8a, 0xe3, 0x97, 0x90,
	0x37, 0xcf, 0x6f, 0x3a, 0x7d, 0x1d, 0x35, 0xb5, 0x56, 0xd9, 0x8c, 0x16, 0x31, 0x7a, 0xd6, 0x57,
	0xf6, 0x23, 0xf4, 0x2c, 0x41, 0xdf, 0xf6, 0x75, 0x6d, 0x83, 0xbe, 0x4d, 0xd0, 0x6e, 0x5f, 0x3f,
	0xdd, 0xa0, 0xdd, 0xbe, 0xb1, 0xd6, 0xe0, 0xfd, 0xd4, 0x56, 0x79, 0xe8, 0x09, 0xdc, 0x00, 0x98,
	0xc7, 0xe0, 0xe6, 0xe0, 0x76, 0x10, 0xfc, 0x15, 0xbc, 0xb4, 0xbd, 0x90, 0xd3, 0x40, 0x4c, 0x03,
	0x16, 0x3a, 0xd3, 0x79, 0x28, 0x6e, 0x67, 0xae, 0xaf, 0xe7, 0x9a, 0xa8, 0x95, 0x33, 0x6b, 0xfb,
	0xb1, 0x1f, 0x5c, 0x3f, 0x93, 0x42, 0x96, 0x8e, 0xae, 0x65, 0x53, 0xce, 0x97, 0x4e, 0x76, 0x15,
	0xb2, 0x52, 0xc7, 0x9d, 0x55, 0x85, 0xac, 0x24, 0x25, 0xcc, 0x32, 0x96, 0x8f, 0x28, 0x61, 0xb6,
	0xb1, 0x30, 0xcb, 0x58, 0x21, 0x9b, 0x12, 0x1b, 0x0b, 0xb3, 0x8c, 0x15, 0x8f, 0x54, 0x21, 0x2b,
	0xfc, 0x06, 0x2a, 0x1e, 0x11, 0xd4, 0xb7, 0xee, 0x95, 0x9f, 0x92, 0xca, 0x84, 0x18, 0x92, 0x36,
	0x76, 0x12, 0x64, 0xf5, 0x72, 0x2a, 0x41, 0x16, 0xdd, 0x55, 0x20, 0x2b, 0x1d, 0xd2, 0x0a, 0x64,
	0x65, 0xfc, 0x8d, 0xe0, 0xcd, 0x4e, 0x2b, 0x7b, 0x1e, 0xe1, 0xdc, 0xfd, 0xd5, 0xb5, 0x88, 0xba,
	0x60, 0x4f, 0x6b, 0x6c, 0x17, 0x3e, 0x38, 0x38, 0x72, 0x4b, 0x0a, 0xa9, 0xd6, 0xe6, 0xcd, 0x57,
	0xfb, 0x51, 0x55, 0x45, 0xd2, 0xc2, 0x6c, 0x9a, 0x16, 0xd1, 0xc2, 0x4c, 0xda, 0x27, 0x50, 0x4d,
	0xb6, 0x14, 0x65, 0x47, 0x3f, 0xd2, 0xb3, 0x18, 0x54, 0x49, 0xc6, 0x1f, 0x08, 0xf0, 0xe1, 0xcf,
	0xf8, 0xe8, 0x4e, 0x5e, 0x43, 0xc9, 0x23, 0xc2, 0x15, 0xa1, 0x4d, 0xe3, 0x6b, 0xb9, 0x59, 0xcb,
	0xb1, 0xe0, 0x31, 0xdf, 0x89, 0x82, 0xd1, 0x05, 0xdc, 0x02, 0x32, 0x2a, 0xdc, 0x19, 0xe5, 0x82,
	0xcc, 0xe6, 0xea, 0xe2, 0x68, 0xe6, 0x16, 0x90, 0xba, 0xc4, 0x8b, 0x75, 0xa3, 0x2b, 0xb2, 0x59,
	0x1b, 0x14, 0x9e, 0x27, 0xf3, 0x87, 0xcf, 0x99, 0xcf, 0xe9, 0x23, 0x03, 0xa8, 0x0b, 0xc5, 0x40,
	0xf5, 0x25, 0x99, 0x3f, 0x1f, 0x1d, 0x99, 0x3f, 0x32, 0xc7, 0x4c, 0x72, 0x8d, 0xdf, 0x11, 0xd4,
	0xa3, 0x3a, 0x07, 0x3d, 0x7e, 0x4a, 0xd5, 0xde, 0x7e, 0xd5, 0xcf, 0x32, 0xab, 0x66, 0xdd, 0x9f,
	0xad, 0x87, 0x36, 0xe0, 0xef, 0x29, 0xf1, 0xc4, 0xb4, 0x37, 0xa5, 0xd6, 0x6f, 0x49, 0x53, 0x74,
	0x28, 0x72, 0x1a, 0x2c, 0x5d, 0x8b, 0xaa, 0xb2, 0x65, 0x33, 0x59, 0x1a, 0xff, 0x20, 0xa8, 0xa5,
	0x08, 0xb1, 0xd5, 0x1e, 0x14, 0xb8, 0x20, 0x22, 0xe4, 0x8a, 0xf0, 0xbc, 0xf3, 0xf9, 0xd6, 0x4b,
	0x46, 0x7a, 0x7b, 0x22, 0xe5, 0x7c, 0x67, 0xa2, 0x28, 0x66, 0x4c, 0x95, 0xfb, 0xa5, 0x41, 0xc0,
	0x02, 0x8b, 0xc5, 0xcd, 0xce, 0x9b, 0x5b, 0x00, 0x1b, 0xf0, 0x6c, 0xc6, 0x6c, 0xea, 0x2d, 0x69,
	0xc0, 0xe5, 0x24, 0xd6, 0x94, 0xb3, 0x14, 0x66, 0x7c, 0x03, 0xd5, 0x94, 0x34, 0xae, 0x40, 0xf1,
	0xc7, 0xe1, 0x60, 0x78, 0xfd, 0xf3, 0xf0, 0xc5, 0x89, 0x5c, 0x4c, 0xbe, 0x33, 0x7f, 0xba, 0x1a,
	0xf6, 0x5f, 0x20, 0xfc, 0x1e, 0x54, 0x86, 0xd7, 0x37, 0xb7, 0x09, 0x90, 0xeb, 0xfc, 0x89, 0xa0,
	0x34, 0x96, 0xa6, 0xc7, 0x6c, 0x82, 0x2f, 0xa1, 0x92, 0x7c, 0x0f, 0x46, 0x57, 0x78, 0x67, 0xde,
	0xa7, 0x5e, 0xa6, 0xd7, 0xfa, 0x61, 0x20, 0xda, 0xa2, 0x71, 0xf2, 0x25, 0xc2, 0xbf, 0xc0, 0xab,
	0x1d, 0x95, 0xa4, 0x13, 0x34, 0x38, 0xae, 0xf7, 0xe9, 0x7e, 0x20, 0xfb, 0x6a, 0x48, 0xf5, 0xce,
	0x10, 0x0a, 0xd1, 0xd9, 0xe2, 0x4b, 0xc8, 0xab, 0xf3, 0xc5, 0xf5, 0x23, 0xc7, 0x1e, 0x89, 0x7f,
	0xfc, 0xce, 0xa6, 0x5c, 0x7c, 0xb1, 0xfe, 0xaf, 0x71, 0xb2, 0x7e, 0x68, 0xa0, 0xbf, 0x1e, 0x1a,
	0xe8, 0xdf, 0x87, 0x06, 0x82, 0x9a, 0x2d, 0x88, 0xd3, 0x8e, 0xde, 0xe8, 0xe4, 0xc5, 0xbe, 0x38,
	0x1d, 0x8f, 0xd9, 0x64, 0x84, 0xee, 0x0a, 0xea, 0xdd, 0x3e, 0xfb, 0x3f, 0x00, 0x00, 0xff, 0xff,
	0x67, 0x42, 0x13, 0xdb, 0xce, 0x07, 0x00, 0x00,
}
