package main

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"fmt"
	tdgproto "github.com/mobiledgex/edge-cloud-infra/operator-api-gw/tdg/proto"
	edgetls "github.com/mobiledgex/edge-cloud/tls"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"io/ioutil"
	"os"
	"strings"
	//queryqos "github.com/mobiledgex/edge-cloud-infra/operator-api-gw/tdg/tdg-qos/proto"
)

var serverAddr string = "qos-predictive.all-ip.t-online.de:8001"

var clientCertFile string = "/root/tls/qosclient.crt"
var serverCertFile string = "/root/tls/qosserver.crt"

func getClientCertificate(tlsCertFile string) (tls.Certificate, error) {
	if tlsCertFile == "" {
		return tls.Certificate{}, nil
	}
	keyFile := strings.Replace(tlsCertFile, "crt", "key", 1)
	certificate, err := tls.LoadX509KeyPair(
		tlsCertFile,
		keyFile,
	)
	if err != nil {
		return tls.Certificate{}, err
	}
	return certificate, nil
}

func getClientCertPool() (*x509.CertPool, error) {

	// get the public certs from the host's cert pool
	certPool, err := x509.SystemCertPool()
	if err != nil {
		return nil, fmt.Errorf("fail to load system cert pool")
	}
	// append the mex ca if present. If not, we will only trust public signed certs
	bs, err := ioutil.ReadFile(serverCertFile)
	if err == nil {
		ok := certPool.AppendCertsFromPEM(bs)
		if !ok {
			return nil, fmt.Errorf("fail to append certs")
		}
	}
	return certPool, nil
}

func getTlsConfig() (*tls.Config, error) {

	certPool, err := getClientCertPool()
	if err != nil {
		return nil, err
	}
	certificate, err := getClientCertificate(clientCertFile)
	if err != nil {
		return nil, err
	}

	serverName := strings.Split(serverAddr, ":")[0]
	return &tls.Config{
		ServerName:         serverName,
		InsecureSkipVerify: false,
		Certificates:       []tls.Certificate{certificate},
		RootCAs:            certPool,
	}, nil

}

func main() {

	fmt.Printf("Connecting to %s\n", serverAddr)

	tlsConfig, err := getTlsConfig()
	fmt.Printf("TLSCONFIG: %+v Err: %v\n", tlsConfig, err)
	//tlsConfig.InsecureSkipVerify = true

	transportCreds := credentials.NewTLS(tlsConfig)
	dialOption := grpc.WithTransportCredentials(transportCreds)
	conn, err := grpc.Dial(serverAddr, dialOption)
	if err != nil {
		fmt.Printf("ERROR %v", err)
		os.Exit(1)
	}
	defer conn.Close()
	ctx := context.TODO()
	var request tdgproto.QoSKPIRequest
	request.Requestid = 1
	qosClient := tdgproto.NewQueryQoSClient(conn)
	fmt.Printf("QOSCLIENT: %v\n", qosClient)

	qosclient, err := qosClient.QueryQoSKPI(ctx, &request)
	fmt.Printf("streamclient: %v, err: %v\n", qosclient, err)

}
